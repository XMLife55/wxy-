

![img](https://img-blog.csdnimg.cn/3cd1fd2f36b94b76bd6cb3b2bcbf2c27.png)

- ***\*应用层\****（http、https）**：** 数据的使用。
- ***\*传输层\****（UDP、TCP）**：**网络通讯的细节，将数据可靠的从A主机跨网络送到B主机。
- ***\*网络层\****（IP）**：**提供一种能力，将数据从A主机送到B主机的能力。

---



## 1. IP协议

IP协议全称为“网际互连协议（Internet Protocol）”，IP协议是TCP/IP体系中的网络层协议。

---

### 基本概念

- 网络层解决的问题

TCP作为传输层控制协议，其保证的是数据传输的可靠性和传输效率，但TCP提供的仅仅是数据传输的策略，而真正负责数据在网络中传输的则传输层之下的网络层和链路层。



- 双方在进行网络通信时，发送的数据并不是直接从一方的传输层直接发送到了另一方的传输层，而是需要传输层将数据继续向下进行交付，在网络层和链路层经过数据封装后再通过网络发送到对方主机，对方主机收到数据后也同样需要在链路层和网络层进行数据解包，此时对方的传输层才拿到了发送过来的数据，然后再继续将该数据向上进行交付。

  

网络通信的过程，就像两个人在送互相送数据，这两个人分别在两栋楼的四楼，如果一个人要将数据交给对方，那么这个人就必须先从四楼走到一楼，然后再在路上经过路径选择到达对方楼下，最后再上到四楼将数据交给对方。

![img](https://img-blog.csdnimg.cn/d3d45890320c4d09ad372b0d28203ca6.png)



其中，送数据的这个人从四楼下来的过程就是数据封装的过程，这个人在路上经过路径选择到达对方楼下的过程就是数据路由的过程，而这个人再上到四楼将数据交给对方的过程就是数据解包的过程。



- 而网络层要解决的问题就是，将数据从一台主机送到另一台主机，也就是数据的路由。

> 保证数据可靠的从一台主机送到另一台主机的前提



当双方在进行基于TCP的网络通信时，要保证将数据可靠的从一台主机送到另一台主机，前提是发送方要有将数据送到对方主机的能力，要是发送方连将数据发送给对方的能力都没有，那就更不用谈可靠的将数据送给对方主机了。



- 需要注意的是，发送方有将数据送到对方主机的能力，并不意味着发送方每次发送的数据都能够成功的发送到对方，但如果发送方连将数据发送给对方的能力都没有，那发送方基本就不可能将数据发送给对方。
- 一旦发送方有了将数据发送给对方的能力，就算发送方某次发送的数据没有成功到达对方，此时上层TCP由于没有收到对应数据的应答，此时上层TCP会要求进行数据重发，直到数据成功发送到对方主机为止。



也就是说，在网络层有能力将数据送到对方主机的情况下，虽然网络层不能保证每次都能将数据成功送到对方主机，但在TCP提供的可靠性策略的保证下，最终网络层就一定能够将数据可靠的发送到对方主机。





- **说明一下：**
  - 网络层解决的问题是，将数据从一台主机送到另一台主机，因此网络层解决的是主机到主机的问题。
  - 一方传输层从上方进程拿到数据后，该数据贯穿网络协议栈进行封装和解包，最终到达对方传输层，此时对方传输层也会将数据向上交给对应的进程，因此传输层解决的是进程到进程的问题。



- **路径选择**

  数据进行的网络传输一般都是跨网络的，而路由器就是连接多个网络的硬件设备，因此数据在进行跨网络传输时一定需要经过多个路由器。

![img](https://img-blog.csdnimg.cn/744bbe4123f94490ac330c4fff17a139.png)

数据路由就像我们旅游一样，当确定了要到达的目标主机后，就需要寻找最短的路径到达该目的地。

 

- 目的地的确定是非常重要的，因为目的地直接决定了数据路由时的路径选择，这也是跨网络找到目标主机的根本。
- 只有数据经过了较为正确的路径选择，最终才可能慢慢趋近于目标网络或目标主机。

确定数据路由的目的地后，数据就可以在网络中进行路由了，但数据在路由时无法自行进行路径选择，因为这个数据本身是“不认识路”的，因此数据在路由的过程中需要不断“找路人问路”，而这里所谓的“路人”就是网络当中的一台台路由器。

网络当中的路由器是“认识路的”，它们将自己的“认路经验”都记录到路由表当中，因此路由器可以通过查路由表找到去特定点的最短路径。因此数据在路由时，会不断通过路由器来进行路径选择，以此来一步步靠近目标网络或目标主机。

![img](https://img-blog.csdnimg.cn/16ca94d37e7f4121a68811d085af4808.png)



- **主机和路由器**
  - 主机：配有IP地址，但是不进行路由控制的设备。但实际现在几乎不存在不进行路由控制的设备了，就连你的笔记本也会进行路由控制。
  - 路由器：既配有IP地址，又能进行路由控制。实际现在主流的路由器已经不仅仅具有路由的功能了，它甚至具备某些应用层的功能。
  - 节点：主机和路由器的统称。

----



### IP协议格式

IP协议格式如下：

![img](https://img-blog.csdnimg.cn/cb78e7a4a25a4b75a9e2aa1ec04c9ea8.png)

​    **可以发现IP报文的形式与TCP报文的形式非常的类似，也可以发现喜欢叫它们都喜欢叫为：TCP/IP协议。**



- 4位版本号（version）：指定IP协议的版本（IPv4/IPv6），对于IPv4来说，就是4。
- 4位首部长度（header length）：表示IP报头的长度，以4字节为单位。
- 8位服务类型（Type Of Service）：3位优先权字段（已经弃用），4位TOS字段，和1位保留字段（必须置为0）。4位TOS分别表示：最小延时，最大吞吐量，最高可靠性，最小成本。这四者相互冲突，只能选择一个。比如对于ssh/telnet这样的应用程序，最小延时比较重要，而对于ftp这样的程序，最大吞吐量比较重要。
- 16位总长度（total length）：IP报文（IP报头+有效载荷）的总长度，用于将各个IP报文进行分离。
- 16位标识（id）：唯一的标识主机发送的报文，如果数据在IP层进行了分片，那么每一个分片对应的id都是相同的。
- 3位标志字段：第一位保留，表示暂时没有规定该字段的意义。第二位表示禁止分片，表示如果报文长度超过MTU，IP模块就会丢弃该报文。第三位表示“更多分片”，如果报文没有进行分片，则该字段设置为0，如果报文进行了分片，则除了最后一个分片报文设置为0以外，其余分片报文均设置为1。
- 13位片偏移（framegament offset）：分片相对于原始数据开始处的偏移，表示当前分片在原数据中的偏移位置，实际偏移的字节数是这个值× 8 \times 8×8得到的。因此除了最后一个报文之外，其他报文的长度必须是8的整数倍，否则报文就不连续了。
- 8位生存时间（Time To Live，TTL）：数据报到达目的地的最大报文跳数，一般是64，每经过一个路由，TTL -= 1，一直减到0还没到达，那么就丢弃了，这个字段主要是用来防止出现路由循环。
- 8位协议：表示上层协议的类型。
- 16位首部检验和：使用CRC进行校验，来鉴别数据报的首部是否损坏，但不检验数据部分。
- 32位源IP地址和32位目的IP地址：表示发送端和接收端所对应的IP地址。
- 选项字段：不定长，最多40字节。



IP报头在内核当中本质就是一个位段类型，给数据封装IP报头时，实际上就是用该位段类型定义一个变量，然后填充IP报头当中的各个属性字段，最后将这个IP报头拷贝到数据的首部，至此便完成了IP报头的封装。

---

#### **4位版本**



![image-20240320183243378](C:\Users\。\AppData\Roaming\Typora\typora-user-images\image-20240320183243378.png)

​    4位版本号(version)：指定IP协议的版本，对于IPv4来说，就是4。



- **IPv4与IPv6**

  - IPv4 : 4字节、32bit位来表示IP地址。

  - IPv6 : 主要原因是IPv4是由32位表示，所以数量上全球只能有 2^23 个IP地址，只有42亿多，现在远远不够了，但是现在网络没有崩是因为使用到了一些技术，而彻底的解决的方案就是IPv6。IPv6选择的是使用128位的bit位来表示IP地址，数量上全球能有2^128 个IP地址使用，所以量是极其大的。

    > 但是有一个遗憾，就是IPv4和IPv6是不兼容的，想要切换就相当于将量极其庞大的安卓手机全部切换为IOS系统。

    

​		

---

#### **4位首部长度**



- **IP如何将报头与有效载荷进行分离？**

  ![image-20240320183005822](C:\Users\。\AppData\Roaming\Typora\typora-user-images\image-20240320183005822.png)
  
  > IP分离报头与有效载荷的方法与TCP是一模一样的，当IP从底层获取到一个报文后，虽然IP不知道报头的具体长度，但IP报文的前20个字节是IP的基本报头，并且这20字节当中涵盖4位首部长度。

​	- 因此IP是这样分离报头与有效载荷的：

- 当IP从底层获取到一个报文后，首先读取报文的前20个字节，并从中提取出4位的首部长度，此时便获得了!P报头的大小size。
- 如果sixe的值大于20字节，则需要继续从报文当中读取size - 20字节的数据，这部分数据就是IP报头当中的选项字段。
- 读取完IP的基本报头和选项字段后，剩下的就是有效载荷了。

IP就是通过这种“定长报头+自描述字段”的方式进行报头和有效载荷的分离的。但需要注意的是，IP报头当中的4位首部长度描述的基本单位与TCP报头当中的4位首部长度一样，都是以4字节为单位进行描述的，这也恰好是报文的宽度。

4位二进制的取值范围是0000~1111，因此IP报头的最大长度为15 x4= 60字节，因为基本报头的长度是20字节，所以P报头中选项字段的长度最多是40字节。如果iP报头当中不携带选项字段，那么iP报头的长度就是20字节，此时报头当中的4位首部长度字段所填的值就是20/4=5，即0101。



---



#### **8位协议**

- **IP如何决定将有效载荷交付给上层的哪一个协议？**

基于IP协议的传输层协议不止一种，因此当IP从底层获取到一个报文并对其进行解包后，IP需要知道应该将分离后得到的有效载荷交付给上层的哪一个协议。

在IP报头当中有一个字段叫做8位协议，该字段表示的就是上层协议的类型，IP就是根据该字段判定应该将分离出来的有效载荷交付给上层的哪一个协议的。该字段是发送方的IP层从上层传输层获取到数据后填充的，比如是上层TCP交给IP层的数据，那么该数据在封装IP报头时的8位协议填充的就是TCP对应的编号。

![image-20240320183146977](C:\Users\。\AppData\Roaming\Typora\typora-user-images\image-20240320183146977.png)





---

#### **32位源IP地址和32位目的IP地址**

![image-20240320183554662](C:\Users\。\AppData\Roaming\Typora\typora-user-images\image-20240320183554662.png)

IP报头当中的32位源IP地址和32位目的IP地址，分别代表的就是该报文的发送端和接收端对应的IP地址。

数据在网络传输过程中会遇到一个个的路由器，这些路由器会帮助网络当中的数据进行路由转发，使得网络中的数据慢慢趋近于目标主机。路由器在帮助数据进行路由转发时，会提取出该数据的IP报头当中的目的IP地址，并以此作为数据路由转发的重要依据。

当接收端收到了发送端发来的数据后，接收端可能也想要给发送端发送数据，因此发送端在发送数据时除了需要指明该数据的目的IP地址，还需要指明该数据的源IP地址，也就是发送端的IP地址。即便接收端收到数据后没有数据想要发送给发送端，但至少接收端需要向发送端发送一个响应报文，表明发送端发送的数据已经被接收端可靠的收到了，因此发送出去的数据除了需要指明该数据的目的IP地址，还需要指明该数据的源IP地址。





---

- **理解socket编程：**
  - 在进行socket编程的时候，当一端想要发送数据给另一端时，必须要指明对端的IP地址和端口号，也就是发送数据的目的IP地址和目的端口号。
  - 其中这里的IP地址就是给网络层的IP用的，用于数据在网络传输过程中的路由转发，而这里的端口号就是给传输层的TCP或UDP用的，用于指明该数据应该交给上层的哪一个进程。
  - 发送数据时我们不需要指明发送数据的源IP地址和源端口号，因为传输层和网络层都是在操作系统内核当中实现的，数据在进行封装时操作系统会自行填充上对应的源IP地址和源端口号。

---



#### 8位生存时间

![image-20240320183759947](C:\Users\。\AppData\Roaming\Typora\typora-user-images\image-20240320183759947.png)

报文在网络传输过程中，可能因为某些原因导致报文无法到达目标主机，比如报文在路由时出现了环路路由的情况，或者目标主机已经异常离线了，此时这个报文就成了一个废弃的游离报文。

为了避免网络当中出现大量的游离报文，于是在IP的报头当中就出现了一个字段，叫做8位生存时间（Time To Live，TTL）。8位生存时间代表的是报文到达目的地的最大报文跳数，每当报文经过一次路由，这里的生存时间就会减一，当生存时间减为0时该报文就会被自动丢弃，此时这个报文就会在网络中消散。

**8位生存时间**本质上就是**计数器**

---



#### **16为首部校验和**

![image-20240320184157354](C:\Users\。\AppData\Roaming\Typora\typora-user-images\image-20240320184157354.png)

 如果在首部检验的时候，如果检验失败了，那么该IP报文直接被丢弃。

- **怕不怕一个IP报文被丢弃？**

  ​    根本不怕，如果一个IP报文出现整体丢失的情况，发送方主机会进行丢包重传（丢包没有ACK然后会超时重传，意味着在TCP中，该数据会一直停留在滑动窗口中）。因为有可能因为一些硬件电路的问题，导致出现一些问题，比如：bit位翻转（0 -> 1，1 -> 0）





---



### [分片](https://so.csdn.net/so/search?q=分片&spm=1001.2101.3001.7020)与组装



- 数据链路层解决的问题

IP能够将数据跨网络从一台主机送到另一台主机，而数据在进行跨网络传送时，需要经过一个个的路由器进行路由转发，最终才能到达目标主机。

比如要将数据从主机B跨网络传送到主机C，那么主机B需要先将数据交给路由器F，路由器F再将数据交给路由器G，…，最终由路由器D将数据交给主机C。

![img](https://img-blog.csdnimg.cn/16ca94d37e7f4121a68811d085af4808.png)

因此IP进行数据跨网络传送的前提是，需要先将数据从一个节点传送到和自己相连的下一个节点，这个问题实际就是由IP之下的数据链路层解决的，其中数据链路层最典型的代表协议就是MAC帧。

而两个节点直接相连也就意味着这两个节点是在同一个局域网当中的，因此要讨论两个相邻节点的数据传送时，实际讨论的就是局域网通信的问题。



- **最大传输单元 MTU**

  MAC帧作为数据链路层的协议，它会将IP传下来的数据封装成数据帧，然后发送到网络当中。但MAC帧携带的有效载荷的最大长度是有限制的，也就是说IP交给MAC帧的报文不能超过某个值，这个值就叫做最大传输单元（Maximum Transmission Unit，MTU），这个值的大小一般是1500字节。

  

  在Linux下使用`ifconfig`命令可以查看对应的MTU。

![img](https://img-blog.csdnimg.cn/f354ae9fbb1246b2ba361ef8b0db6d69.png)

由于MAC帧无法发送大于1500字节的数据，因此IP层向下交付的数据的长度不能超过1500字节，这里所说的数据包括IP的报头和IP的有效载荷。



- **分片与组装**

  如果IP层要传送的数据超过了1500字节，那么就需要先在IP层对该数据进行分片，然后再将分片后的数据交给下层MAC帧进行发送。

![img](https://img-blog.csdnimg.cn/26951bd6cee8488181ab4b56c56d342a.png)

如果发送数据时在IP层进行了分片，那么当这些分片数据到达对端主机的IP层后就需要先进行组装，然后再将组装好的数据交付给上层传输层。

![img](https://img-blog.csdnimg.cn/4c080dea345342ffbdc2e90384e512b7.png)



注意：

-  数据的分片不是经常需要做的，实际在网络通信过程中不分片才是常态，因为数据分片会存在一些潜在的问题，比如分片可能会增加丢包的概率。
- 数据的分片和组装发生在IP层，不仅源端主机可能会对数据进行分片，数据在路由过程中的路由器也可能对数据进行分片。因为不同网络的MTU是不一样的，如果传输路径上的某个网络的MTU比源端网络的MTU小，那么路由器就可能对IP数据报再次进行分片。
- 分片数据的组装只会发生在目的端的IP层。
- 在分片的数据中，每一个分片在IP层都会被添加上对应的IP报头，而传输层添加的报头只会出现在第一个分片中，因此网络中传输的数据包可能没有传输层的报头。



- **数据的分片和组装都是由IP层完成的**

数据的分片和组装都是在IP层完成的，上层的传输层和下层的链路层并不关心。

传输层只负责为数据传送提供可靠性保证，比如当数据传送失败后，传输层的TCP协议可以组织进行数据重传。

- 当TCP将待发送的数据交给IP后，TCP并不关心该数据是否会在IP层进行分片，即TCP并不关心数据具体的发送过程。
- 当TCP从IP获取到数据后，TCP也不关心该数据是否在IP层经过了组装。

而链路层的MAC帧只负责，将数据从一个节点传送到和自己相连的下一个节点。

- 当IP将待发送的数据交给MAC帧后，MAC帧并不知道该数据是IP经过分片后的某个分片数据，还是一个没有经过分片的数据，MAC帧只知道它一次最多只能发送MTU大小的数据，如果IP交给MAC帧大于MTU字节的数据，那MAC帧就无法进行发送。
- 当MAC帧从网络中获取到数据后，MAC帧也不关心这个数据是否需要进行组装，MAC帧只需要将该数据的MAC帧报头去掉后直接上交给上层IP就行了，而至于该数据的组装问题则是IP需要解决的。

因此，数据的分片和组装完全是由IP协议自己完成的，传输层和链路层不必关心也不需要关心。

---



#### **16位标识** 、**3位标志字段**、**13位片偏移**



- **分片的过程**

  假设IP层要发送4500字节的数据，由于该数据超过了MAC帧规定的MTU，因此IP需要先将该数据进行分片，然后再将一个个的分片交给MAC帧进行发送。

  IP报头如果不携带选项字段，那么其大小就是20字节，假设IP层添加的IP报头的长度就是20字节，并按下列方式将数据分片后形成了四个分片报文：

  

  | 分片 | 总字节数 | IP报头字节数 | 数据字节数 |
  | ---- | -------- | ------------ | ---------- |
  | 1    | 1500     | 20           | 1480       |
  | 2    | 1500     | 20           | 1480       |
  | 3    | 1500     | 20           | 1480       |
  | 4    | 80       | 20           | 60         |



需要注意的是，分片后的每一个分片数据都需要封装上对应的IP报头，因此4500字节的数据至少需要分为四个分片报文进行发送。

分片报文到达对方的IP层后需要被重新组装起来，因此IP层在对数据进行分片时需要记录分片的信息，而IP报头当中的16位标识、3位标志和13位片偏移实际就是与数据分片相关的字段。

 ![image-20240318233838700](C:\Users\。\AppData\Roaming\Typora\typora-user-images\image-20240318233838700.png)

- 16位标识：唯一标识主机发送的报文，如果数据在IP层进行了分片，那么每一个分片报文的16位标识是相同的。

- 3位标志：

  > 1. 第一位：保留（保留的意思是现在不用，但是还没想好说不定以后要用到）。
  >
  > 2. 第二位：为1表示禁止分片，这时候如果报文长度超过MTU，IP模块就会丢弃报文。
  > 3. 第三位：表示“更多分片”，如果报文没有进行分片，则该字段设置为0，如果报文进行了分片，则除了最后一个分片报文设置为0以外，其余分片报文均设置为1。

- 13位片偏移:分片相对于原始数据开始处的偏移，表示当前分片在原数据中的偏移位置，实际偏移的字节数是这个值 / 8得到的。因此除了最后一个报文之外，其他报文的长度必须是8的整数倍，否则报文就不连续了。

  

因此上述四个分片报文对应的16位标识都是一样的，假设四个分片报文的16位标识都是123，则这四个报文对应的16位标识、3位标志中的“更多分片”和13位片偏移分别如下：

| 分片 | 总字节数 | IP报头字节数 | 数据字节数 | 16位标识 | 更多分片 | 13位片偏移 |
| ---- | -------- | ------------ | ---------- | -------- | -------- | ---------- |
| 1    | 1500     | 20           | 1480       | 123      | 1        | 0          |
| 2    | 1500     | 20           | 1480       | 123      | 1        | 185        |
| 3    | 1500     | 20           | 1480       | 123      | 1        | 370        |
| 4    | 80       | 20           | 60         | 123      | 0        | 555        |

需要注意的是，13位片偏移当中记录的字节数是当前分片在原数据开始处的偏移字节数的值 / 8得到的，比如分片报文2在原始数据开始处的偏移字节数是1480，其对应的13位片偏移的值就是1480 / 8 = 185。

![img](https://img-blog.csdnimg.cn/50afd2738bb44c1c820beb44a9768981.png)

---



- **组装的过程**

MAC帧交给IP层的数据可能来自世界各地，这些数据可能是经过分片后发送的，也可能是没有经过分片直接发送的，因此IP必须要通过某种方式来区分收到的各个数据。

- IP报头当中有32位源IP地址，源IP地址记录了发送端所对应的IP地址，因此通过IP报头当中的32位源IP地址就可以区分来自不同主机的数据。
- IP报头当中有16位标识，未分片的数据各自的16位标识都是不同的，而由同一个数据分片得到的各个分片报文所对应的16位标识都是相同的，因此通过IP报头当中16位标识就可以判断哪些报文是没有经过分片的独立报文，哪些报文是经过分片后的分片报文。![image-20240318235353421](C:\Users\。\AppData\Roaming\Typora\typora-user-images\image-20240318235353421.png)



因此IP可以通过IP报头当中的32位源IP地址和16位标识，将经过分片的数据各自聚合在一起，聚合在一起后就可以开始进行组装了。

对于各个分片报文来说：

- 第一个分片报文中的13位片偏移的值一定为0。
- 最后一个分片报文中的“更多分片”标志位一定为0。
- 对于每一个分片报文来说，当前报文的13位片偏移加上当前报文的数据字节数 ÷ 8所得到的值，就是下一个分片报文的所对应的13位片偏移。
  

根据分片报文的这三个特点就能够将分片报文合理的组装起来。

-  先找到分片报文中13位片偏移为0的分片报文，然后提取出其IP报头当中的16位总长度字段，通过计算即可得出下一个分片报文所对应的13位片偏移，按照此方式依次将各个分片报文拼接起来。
- 直到拼接到一个“更多分片”标志位为0的分片报文，此时表明分片报文组装完毕。



- **分片报文丢包的问题**

  分片后的报文在网络传输过程中也可能会出现丢包问题，但接收端有能力判断是否收到了全部分片报文，比如假设某组分片报文对应的16位标识值为x：

  - 如果分片报文中的第一个分片报文丢包了，那么接收端收到的分片报文中就找不到对应16位标识为x，并且13位片偏移为0的分片报文。

  - 如果分片报文中的最后一个分片报文丢包了，那么接收端收到的分片报文中就找不到对应16为标识为x，并且“更多分片”标志位为0的分片报文。

  - 如果分片报文中的其它分片报文丢包了，那么接收端在进行分片报文的组装时就会找不到对应13位片偏移为特定值的分片报文。

    

   需要注意的是，未分片报文的“更多分片”标志位为0，最后一个分片报文的“更多分片”标志位也为0，但当接收端只收到分片报文中的最后一个分片报文时，接收端不会将其识别成一个未分片的报文，因为未分片的报文所对应的13位片偏移的值也应该是0，而最后一个分片报文所对应的13位片偏移的值不为0。

  

  因此只有当一个报文的13位片偏移为0，并且该报文的“更多分片”标志位也为0时，该报文才会被识别成一个没有被分片的独立报文，否则该报文就会被识别成一个分片报文。

  ---

  

- **为什么不建议进行分片？**

虽然传输层并不关心IP层的分片问题，但分片对传输层也是有影响的。

- 如果一个数据在网络传输过程中没有经过分片，那么只要接收端收到了这一个报文，我们就可以认为该数据被对方可靠的收到了。
- 而如果一个数据在网络传输过程中进行了分片，那么只有当接收端收到了全部的分片报文并将其成功组装起来，这时我们才认为该数据被对方可靠的收到了。但如果众多的分片报文当中有一个报文出现了丢包，就会导致接收端就无法将报文成功组装起来，这时接收端会将收到的分片报文全部丢弃，此时传输层TCP会因为收不到对方应答而进行超时重传。
- 假设在网络传输时丢包的概率是万分之一，如果将数据拆分为一百份进行发送，那么此时丢包的概率就上升到了百分之一。因为只要有一个分片报文丢包了也就等同于这个报文整体丢失了，因此分片会增加传输层重传数据的概率。

需要注意的是，只要分片报文当中的某一个出现了丢包，此时传输层都需要将数据整体进行重传，因为传输层并不知道底层IP对数据进行了分片，当传输层发送出去的数据得不到应答时传输层就只能将数据整体进行重传，因此数据在发送时不建议进行分片。

---



- **如何尽可能避免分片？**

  > 实际数据分片的根本原因在于传输层一次向下交付的数据太多了，导致IP无法直接将数据向下交给MAC帧，如果传输层控制好一次交给IP的数据量不要太大，那么数据在IP层自然也就不需要进行分片。

- 因此TCP作为传输控制协议，它需要控制一次向下交付数据不能超过某一阈值，这个阈值就叫做MSS（Maximum Segment Size，最大报文段长度）。
- 通信双方在建立TCP连接时，除了需要协商自身窗口大小等概念之外，还会协商后续通信时每一个报文段所能承载的最大报文段长度MSS。

MAC帧的有效载荷最大为MTU，TCP的有效载荷最大为MSS，由于TCP和IP常规情况下报头的长度都是20字节，因此一般情况下 MSS = MTU - 20 - 20，而MTU的值一般是1500字节，因此MSS的值一般就是1460字节。

所以一般建议TCP将发送的数据控制在1460字节以内，此时就能够降低数据分片的可能性。之所以说是降低数据分片的可能性，是因为每个网络的链路层对应的MTU可能是不同的，如果数据在传输过程中进入到了一个MTU较小的网络，那么该数据仍然可能需要在路由器中进行分片。

---



### 网段划分



**（宏观原理，便于理解，并不是真正的划分）**

 主流采用的IP地址依旧是IPV4，用32位标识一个主机的唯一性。在整个全球当中，其就如同一个蛋糕一样，在网络刚开始兴起的时候，是首先按照国家 / 地区，将不同种类的IP地址，划分给不同的国家 / 地区。

![img](https://img-blog.csdnimg.cn/58fa81588c104492bb8c37c30669ceb8.png)

![img](https://img-blog.csdnimg.cn/4cc125395fce49d4aa9572d5c203060c.png)

​    如此国际间的路由器就只需要根据前8位，如上图：0000 0000就是中国的，然后0000 0000开头的数据包就直接进入中国内部转发。每个国家的IP地址，在开始的时候，就已经被划分好了，国际上的路由器都有自己的路由表，可以进行国家和国家的转发。

​    以中国为例，中国有23个省，那就以次位的5位表示省份。

![img](https://img-blog.csdnimg.cn/e91767896b5844e496c84ac5d9516716.png)

​    然后就如同上述的国家和国家间转发，省份与省份间也有路由器，其就会根据次5位然后进入省份内部进行转发。

​    然而实际上，每一个国家的经济发展与人口是不一样的，并且每时每秒都是变的，也就代表了入网设备是不一样的。中国内部省份繁荣程度，人口密度也都大不相同，所以这个是需要进行一定的综合评估的。

​    就是**运营商**来评估，并且架设路由器，进行IP地址的规划。所以便有了现在主流的网络环境，然后通过一定的IP划分，再通过一定的IP算法 / IP地址架设规则，来进行区域与区域间的转发。**所以：我们需要将IP地址进行各种划分，各种网络划分的方案**。

---



---

#### **子网**

IP地址分为两个部分：**网络号**、**主机号**。

IP地址由网络号和主机号两部分构成：

- 网络号：保证相互连接的两个网段具有不同的标识。  —— 本质上：表征的就是不同的区域。
- 主机号：同一网段内，主机之间具有相同的网络号，但是必须有不同的主机号。

> 在进行网络转发的时候，需要先进行利用**网络号**进行找到目标网络，再根据**主机号**确认目标主机。

可以在IP地址的后面加一个 /，并在 / 后面加上一个数字，这就表示从头数到第几位为止属于网络标识。

例如，下图中路由器连接了两个网段。对于网络标识来讲，同一网段内主机的网络标识是相同的，不同网段内主机的网络标识是不同的。而对于主机标识来讲，同一网段内主机的主机标识是不同的，不同网段内主机的主机标识是可以相同的。

![img](https://img-blog.csdnimg.cn/15f6674881194687a007a9c6d3dd1606.png)

 **路由器：**一定是能够级联两个不同的[子网](https://so.csdn.net/so/search?q=子网&spm=1001.2101.3001.7020)的，这个子网可能是一个国家，可能是一个省，可能是一个市，也可能是一个公司 / 家庭网络。

​    在进行网络转发的时候，需要先根据**网络号**先确定区域，然后在区域内部继续根据可能区域内部的方案 / 近一步使用**网络号**的后半部分进行缩小区域，然后找到目标主机。

 网络号是标识网段的重要依据，同一个网络内部大家的网络标识一定是一样的，就按前面的例子来说，中国内部的开始8位就一定是0000 0000。但是主机标识是在同一个网段当中一定是不能一样的。



> 相同的网段，网络号一定相同，主机号一定不同。不同的网段，网络号一定不同，主机号可能相同。IP = 网络 + 主机，就如同：(学届 + 院系号 + 专业 + 班号)  + 学号 —— 学校本身就是一个从上到下的网络结构，当我们希望查找到一位同学的时候，通过前几知道是哪一学届，再次几位找到对应的学院，再次几位找到对应的专业、再次几位找到对应的班级，然后才找到学生。这就是网络在转发的时候，先根据网络号进行转发，最后到达了目标地址，再继续找到主机号。网络号是可以在不同的查找过程中，不断放大，并且收敛。
>
> 
>
> - 一个例子：
>
>   一位计算机学院的学生捡到一张学生卡，他可以知道不是自己班的，于是就向上进行询问（找到对应的层次负责人），然后发现不是本专业、随后不是本院系、不是本学届的，随后就到达学校层次，然后就开始向下根据学号找到丢卡同学，然后将计算机学院的学生的联系方式给丢卡同学，让二者进行联系。
>
>   - **捡卡同学：**发送数据端；
>   - **丢卡同学：**接收数据端；
>   - **对应层次的负责人：**路由器；
>   - **负责人所负责的范围：**网段；
>   - **学校层次：**公网。
>
> 

---

- **为什么将IP地址划分为网络号和主机号？**

1. 便于定位。
2. 提高查找效率。

- 不同的子网其实就是把网络号相同的主机放到一起。
- 如果在子网中新增一台主机，则这台主机的网络号和这个子网的网络号一致，但是主机号必须不能和子网中的其他主机重复。

​    通过合理设置主机号和网络号， 就可以保证在相互连接的网络中 ， 每台主机的 IP 地址都不相同 （是一个理想的情况，IPV4本身就不够用，是有对应的方案解决的） 。



---

- **DHCP协议**

  > 实际手动管理IP地址是一个非常麻烦的事情，当子网中新增主机时需要给其分配一个IP地址，当子网当中有主机断开网络时又需要将其IP地址进行回收，便于分配给后续新增的主机使用。

  - 因此对于IP地址的分配和回收一般不会手动进行，而是采用DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）技术。
  - DHCP通常被应用在大型的局域网环境中，其主要作用就是集中地址管理、分配IP地址，使网络环境中的主机动态获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。
  - DHCP是一个基于UDP的应用层协议，一般的路由器都带有DHCP功能，因此路由器也可以看作一个DHCP服务器。

当我们连接WiFi时需要输入密码，本质就是因为路由器需要验证你的账号和密码，如果验证通过，那么路由器就会给你动态分配了一个IP地址，然后你就可以基于这个IP地址进行各种上网动作了。



- **先找目标网络，再找目标主机**

  当IP要将数据跨网络从一台主机发送到另一台主机时，其实不是直接将数据发送到了目标主机，而是先将数据发送到目标主机所在的网络，然后再将数据发送到目标主机。

因此数据在路由时的第一目的并不是找到目标主机，而是找到目标网络所在的网络，然后再在目标网络当中找到目标主机。

数据路由时之所以不一开始就以找目标主机为目的，因为这样效率太低了。

- 找主机的过程本质是排除的过程，如果一开始就以找目标主机为目的，那么在查找的过程中一次只能排除一个主机。
- 而如果一开始先以找目标网络为目的，那么在查找过程中就能一次排除大量和目标主机不在同一网段的主机，这样就可以大大提高检索的效率。

因此，为了提高数据路由的效率，我们对网络进行了网段划分。





- **网段划分**

  过去曾经提出一种划分网络号和主机号的方案，就是把所有IP地址分为五类，如下图所示：

![img](https://img-blog.csdnimg.cn/c42911687f3f48c49acf8068f2911b8c.png)

因此，各类IP地址的取值范围如下：

-  A类：0.0.0.0到127.255.255.255。
- B类：128.0.0.0到191.255.255.255。
- C类：192.0.0.0到223.255.255.255。
- D类：224.0.0.0到239.255.255.255。
- E类：240.0.0.0到247.255.255.255。

当要判断一个IP地址是属于哪一类时，只需要遍历IP地址的前五个比特位，第几个比特位最先出现0值，那么这个IP地址对应就属于A、B、C、D、E类地址。



- **子网划分**

  但随着网络的飞速发展，这种划分方案的局限性很快就显现出来了。

  - 比如一些学校、公司、实验室等组织想要申请自己的局域网，由于A类地址的网络号只占7个比特位，因此A类地址可申请的网络只有27个，于是大多数组织都选择申请B类地址.
  - 由于B类地址的主机号占16个比特位，因此理论上一个B类网络当中允许有65536台主机。
  - 但实际网络架设中，一般不会存在一个局域网当中有这么多主机的情况，也就意味着大量的IP地址实际都被浪费掉了。
  
  

为了避免这种情况，于是又提出了新的划分方案，称为**CIDR（Classless Interdomain Routing）：**

- 引入一个额外的子网掩码(subnet mask)来区分网络号和主机号。
- 子网掩码也是一个32位的正整数，通常用一串 "0" 来结尾。
- 将IP地址和子网掩码进行 "按位与" 操作，得到的结果就是网络号。
- 网络号和主机号的划分与这个IP地址是A类、B类还是C类无关。

​    利用掩码左半部分全1，按位与提取出对应的IP地址的到网络号，剩下的用户未来的提取，就是主机号。

![img](https://img-blog.csdnimg.cn/6fb30b5dd73e4513803f6fe1952b67a7.png)

​     这样就可以通过给不同的路由器配置不同位数的子网掩码，就能够看到不同的网络号。以此通过改变看到的网络号的 "长度" 不断变大（因为子网掩码不断变长），也意味着主机号越来越收敛（"长度" 不断变短）。

​    所以给对应的IP配置子网掩码，将来就可以：**目的IP & 当前路由器的子网掩码 = 该报文要去的目的网络**。因为不同的路由器一定至少要级联2个网络，且每一个网络的网络号可能是不同的，所以每一个路由器也有自己直接连接的网络配置的对应的子网掩码。

![img](https://img-blog.csdnimg.cn/7f9328ace2b3441e96ecad6569832548.png) 

可见，IP 地址与子网掩码做与运算可以得到网络号 ， 主机号从全 0 到全 1 就是子网的地址范围。IP地址和子网掩码还有一种更简洁的表示方法 ， 例如：140.252.20.68/24，表示IP地址为140.252.20.68，子网掩码的高24位是1代表是网络号，后8位就是主机号，也就是255.255.255.0 。



- 实际在用子网掩码与子网当中主机的IP地址进行“按位与”操作时，本质就是保留了主机IP地址中前24个比特位的原貌，将剩下的8个比特位的值清0了而已，也就是将主机号清0了，所以“按位与”后的结果就是该网络对应的网络号。



需要注意的是，子网划分不是只能进行一次，我们可以在划分出来的子网的基础上继续进行子网划分。

- 因此一个数据在路由的时候，随着数据不断路由进入更小的子网，其网络号的位数是在不断变化的，准确来说其网络号的位数是在不断增加的，这也就意味着IP地址当中的主机号的位数在不断减少。最终当数据路由到达目标主机所在的网络时，就可以在该网络当中找到对应的目标主机并将数据交给该主机，此时该数据的路由也就结束了。

  

---

### 特殊的IP地址

并不是所有的IP地址都能够作为主机的IP地址，有些IP地址本身就是具有特殊用途的。

- 将IP地址中的主机地址全部设为0，就成为了网络号，代表这个局域网。
- 将IP地址中的主机地址全部设为1，就成为了广播地址，用于给同一个链路中相互连接的所有主机发送数据包。
- 127.*的IP地址用于本机环回（loop back）测试，通常是127.0.0.1。

也就是说，IP地址中主机号为全0的代表的是当前局域网的网络号，|P地址中主机号为全1的代表的是广播地址，这两个iP地址都是不能作为主机的IP地址的。因此在某个局域网中最多能存在的主机个数是 2^主机号位数  - 2。

---



### 本机环回基本原理

本机环回会将数据贯穿网络协议栈，但最终并不会将数据发送到网络当中，相当于本机环回时不会将数据写到网卡上面。

本机环回的目的就是将数据自顶向下贯穿协议栈，进行一次数据封装的过程的过程，然后再自底向上贯穿协议栈，进行一次数据的解包和分用，用于测试本地的网络功能是否正常。

本机环回的基本原理：

- 当数据到达IP层需要继续向下交付时，如果是环回程序，那么IP输出函数会将该数据放入到IP输入队列当中，然后再由IP输入函数读取上去。
- 而IP输入函数将数据读取上去的本应该是链路层交付上来的数据，因此该数据后续就会被当作从网络中读取上来的数据看待，各层协议会对该数据依次进行解包和分用。
- 如果不是环回程序的话，那么接下来就会判断该数据对应的目的IP地址是否为广播或多播地址，或者目的IP地址是否与本主机的IP地址相同，如果是则也会将该数据放入到IP输入队列当中，等待IP输入函数将其读走。
- 只有判断程序不是环回程序，并且也不是广播或多播，或发给本主机的数据后，才会用ARP获取该数据目的主机的以太网地址并进行后续数据发送的操作。
  

loopback设备：

![img](https://img-blog.csdnimg.cn/7022cc71ac6441999b15e6b3fc751ee0.png)

----



### IP地址的数量限制

> IP地址数量不足问题

我们知道，IP地址(IP4)是一个4字节32位的正整数，因此一共有2^32个iP地址，也就是将近43亿个iP地址。但TCP/IP协议规定，每个主机都需要有一个IP地址。

- 现在全世界人口已经有70多亿了，就算有一半的人没有智能手机，算下来也有30多亿台智能手机需要IP地址。
- 随着科技的发展，我们使用的电脑、智能手表、智能冰箱、智能洗衣机等设备如果要入网也是需要IP地址的。
- 另外，IP地址并不是按照主机台数来配置的，因此一个主机可能需要多个IP地址，更别谈还有很多组网的路由设备也需要IP地址，以及一些特殊的IP地址不能使用的问题。

所以43亿个IP地址其实早就不够用了，因此才提出了CIDR的方案对已经划分好的五类网络继续进行子网划分，其目的就是为了减少IP地址的浪费，根本原因就是IP地址本来就不够了，所以不能够再浪费了。

CIDR虽然在一定程度上缓解了IP地址不够用的问题，因为CIDR提高了IP地址的利用率，减少了浪费，但IP地址的绝对上限并没有增加。



- **如何解决IP地址不足问题**

  解决IP地址不足有以下几种方式：

  - 动态分配IP地址：只给接入网络的设备分配IP地址，因此同一个MAC地址的设备，每次接入互联网中，得到的IP地址不一定是相同的，避免了IP地址强绑定于某一台设备。
  - NAT技术：能够让不同局域网当中同时存在两个相同的IP地址，NAT技术不仅能解决IP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。
  - IPv6：IPv6用16字节128位来表示一个IP地址，能够大大缓解IP地址不足的问题。但IPv6并不是IPv4的简单升级版，它们是互不相干的两个协议，彼此并不兼容，因此目前IPv6还没有普及。

----



### 私网IP地址和公网IP地址

如果一个组织（区域 / 公司 / 高校 / 家）内部组建局域网，那么有一类IP地址是只能用于局域网内的通信，而不直接连到Internet（不能出现在公网）上，理论上使用任意的IP地址都可以，但是 RFC 1918 规定了用于组建局域网的私有IP地址。

- **10.\***，前8位是网络号，共16777216个地址。
- ***\*172.16.到172.31.\****，前12位是网络号，共1048576个地址。
- **192.168.\***，前16位是网络号，共65536个地址。
- 包含在这个范围中的，都成为私有IP，其余的则称为全局IP(或公网IP)。



所以，IP地址被分为了**私有IP地址**和**公网IP地址**。



- **为什么要这么分？这两套网络体系是如何进行的通讯？**

**查看windows的IP地址：**

**1.** 使用***\*cmd\****打开命令行操作窗口。

![img](https://img-blog.csdnimg.cn/2e7827feee8a452bae4161844958eb95.png)



2. 使用***\*ipdonfig\****命令查看。

![img](https://img-blog.csdnimg.cn/9092ba084e824b76af21de3987cf9c54.png)

   此处本人使用的无线网，所以是无线局域网适配器，在里面可以发现IPV4地址以及，子网掩码，默认网关。从子网掩码可以说明，网络号就是192.168.1，而所谓的默认网关就是我们所对应的路由器，一般默认网关是我们的特定子网当中的第一台主机，所以其主机号为1。因为路由器首先是要先构建网络，所以第一台路由器就是先入网的，所以IP地址一般都是当前局域网的第一台主机。

 我们可以看到192.168.*，前16位是网络号，共65536个地址。这也就是为什么我们查我们的IP地址全部几乎都是192.168.*的原因，因为我们用的都是局域网 / 私有网络。如果有云服务器的可以查，几乎都是172.16.到172.31.，前12位是网络号，共1048576个地址。

![img](https://img-blog.csdnimg.cn/e70ed775080c4c148670667a751cf03f.png)

   而如果是虚拟机，并且虚拟机的网络连接方式是 NAT模式 的话，查IP地址几乎都是**10.\***，前8位是网络号，共16777216个地址。

​    换句话说，就是现在我们直接接触到的根本就不是公网IP，而是私网IP。

---



- **我们在家里需要进行上网，我们会先做什么？** 
  1. 有运营商在家附近进行了网络的覆盖。
  
  2. 联系运营商进行光纤入户。
  
  3. 工作人员上门，调制解调器（猫），可能赠送无线路由器。
  
  4. 开户：账号、密码，配置路由器（该账号、密码用于运营商认证）。
  
  5. 配置路由器：设置路由器wifi名称 + 密码（该密码用于路由器认证）。
  
  6. 正常上网，正常缴费。
  
     
  
- **像如华为一样的通讯厂商与运营商的关系。**

  > 可以简单的理解为：运营商是做方案的，是做具体落地的（将网络铺设在什么地方，覆盖面要多大，光纤要怎么埋），而运营商需要的各种各样的设备：路由器交换机、网线、各种服务器……通讯相关的设备，是由如华为一样的通讯厂商提供的。

  

- **我们玩抖音、微信、头条、搜索、外卖……，可是到了月底，话费却给了运营商，为什么？**

  > 我们在入网时候，看起来好像是在上网刷抖音等，进入的是互联网公司，实际上是我们先将将数据请求发送到运营商那里，然后由运营商基站、网线、交换机等，来将我们的数据请求推送到特定的互联网公司所匹配的提供服务的机房，硬件上到达机房之后，软件上再开始进行数据包的向上交付，到达服务的进程，然后为我们提供服务。因为，基础设施是运营商铺设的，就如同高速公路的收费。

  

- **初步理解一下，我们经常听到的，我们是访问不了goole、Facebook等等网站的，为什么？**

  > 都知道我们国家是有墙的，运营商设置的，简单来说就是这路行不通。无论是手机，还是家里的路由器是都有账号的，并且是运营商所知道的。所以有了账号运营商就能认证我们，看在各方因素都合格的情况下，才会进行发送。如余额流量不足，报文直接就丢弃，UDP就直接没了，TCP就多次重传，然后发现都没有任何应答，于是判断网络阻塞，然后判断网络有问题.
  >
  > 
  >
  >  同理的，在发送的IP地址是国外的IP地址的时候就直接拦截我们，也就是直接丢弃我们的报文。



- **如何凸显是运营商将我们的欠费的报文丢弃的？**

  >    在日常生活中，我们一旦欠了费，我们无法给他人拨打电话，但是我们可以给10086拨打电话。

![img](https://img-blog.csdnimg.cn/5202858a95cd46229f801e8a794c1200.png)

 私网里面的所有IP地址都叫做内网IP。所以在我们的数据包没有被发送到公网之前，其实我们所有的报文在转发时都是在从一个子网跳到另一个子网的过程，用的全部都是私有IP。

![img](https://img-blog.csdnimg.cn/ab74c941975843d7832a9b543d7809af.png)

 私有网络对应的IP是局部的，可以在不同的子网中出现重复。于是，IP不足的问题就大大的缓解了。比如中国有23个省，如此每一个区域都可以是一个大型的局域网，大型局域网中，所有人用的私有IP全部都可以是一样的，这样就相当于我们让入网的设备大大的增加，但是消耗IP地址的只有公网当中会消耗对应的IP地址。




- **万一私网中的IP地址不够使用了呢？**

    没有任何问题，那就再下放一个公网IP，然后再继续将网络拆成两个不同的子网，然后这两个子网再使用同样的IP地址。

  然而，正是IPV4这样的策略，所以这也就是IPV6难推的原因，IPV4这样的通过不断的推公网让子网出现重复，于是IPV4能解决，就成为了推行IPV6阻碍。





- **家用路由器**

  - **对内：**面对自己构建的子网。

  - **对外：**自己本身也是别人构建子网的一个主机。



- **决定了路由器一定要有两套地址**
  - **对内：**Lan口IP，局域网IP。
  - **对外：**WAN口IP，自己所在上级子网给自己分配的IP。



- **如何进行的数据包传送？**

  ---

### 报文推送（NAT技术）

 首先让我们看看向外推送，这个时候没有任何问题，找到对应的公网IP就就行了，很简单。

![img](https://img-blog.csdnimg.cn/5e6a5eb4f9d144549e188717af641b86.png)

 但是，如果是这样的方式进行推送，再先将对应的应答数据推送回的时候就会很尴尬，因为目标IP地址将变为私有IP，而公网根本就不认识私网IP（路由器查找上找不到），因为私有IP不会出现在公网上。并且全国有很多的同样IP的地址，目标IP地址（私有IP）并不具备唯一性，无法进行向回推送。

   所以之前的向外推送，只是宏观上，其实细节上，路由器需要做一个事情：将报文中的源IP替换成路由器的WAN口IP，并且经过的每一个运营商的内网路由器，都要做这个工作（公网路由器不需要做）。

所以，站在运营商的路由器来看，其认为该报文是家用路由器给的。站在家用路由器来看，其认为该报文是一个主机给的。而在百度的服务器看来，这个报文的IP就是公网（运营商的路由器WAN口IP），而公网是可以与公网进行通讯的。

![img](https://img-blog.csdnimg.cn/cbf8b0941dc241d5aba1a02f9f900f89.png)

**（如何内网转回，后续讲解……）**

这种源IP地址在不同内网中，不同层级的网络节点中转发，被替换的技术叫做：NAT技术（Network Address Translation，网络地址转化）。



**融汇贯通的理解：**

>  所以实际上运营商做的工作，除了简单的报文转发之外，还在转发的时候可以对我们的数据进行合法性的验证（如：报文是否有非法的内容），如果非法就可以对报文进行拦截、丢弃。当然如此运营商也可以干一些坏事情。如，Https协议中讲到的一种攻击方式：中间人，相对于来说运营商做中间人是十分的简单的，所以Http下的访问连接被更改也是很容易的，毕竟源IP都能被换掉，那数据中的下载连接换掉何尝做不到。
>

- 每一个家用路由器，其实又作为运营商路由器的子网中的一个节点。这样的运营商路由器可能会有很多级，最外层的运营商路由器，WAN口IP就是一个公网IP了。
- 子网内的主机需要和外网进行通信时，路由器将IP首部中的IP地址进行替换（替换成WAN口IP），这样逐级替换，最终数据包中的IP地址成为一个公网IP。这种技术称为**NAT**（Network Address Translation，网络地址转换）。
- 如果希望我们自己实现的服务器程序，能够在公网上被访问到，就需要把程序部署在一台具有外网IP的服务器上。这样的服务器可以在阿里云 / 腾讯云上进行购买。



所以数据要从一个局域网发送到另一个局域网，如果不经过公网是基本上不可能的。我们在和别人聊天的时候，也不是直接将数据从一个局域网直接发送到了另一个局域网，而是先将数据经过公网发送到了服务器，然后再由服务器将数据经过公网转发到了另一个局域网。

但实际确实存在一些技术能够使数据包在发送过程中不进行公网IP的替换，而将数据正确送到目标主机，这种技术叫做内网穿透，也叫做NAT穿透。

---



### 路由

数据“问路”的过程



数据在路由的过程中，实际就是一跳一跳（Hop by Hop）“问路”的过程。所谓“一跳”就是数据链路层中的一个区间，具体在以太网中指从源MAC地址到目的MAC地址之间的帧传输区间。

​    也就是路劲选择的问题，问题是跳往的是哪一个路由器，这个路由器的选择，就是和路由表的算法有关系的，也是子网划分设置好的，是：**子网划分 + 路由表 = 一整套的路由转换方案**。

![img](https://img-blog.csdnimg.cn/544d4039601b44b593e51138cbc03dae.png)

IP数据包的传输过程中会遇到很多路由器，这些路由器会帮助数据包进行路由转发，每当数据包遇到一个路由器后，对应路由器都会查看该数据的目的IP地址，并告知该数据下一跳应该往哪跳。



- IP 数据包的传输过程也和问路一样：：
  - 当IP数据包，到达路由器时，路由器会先查看目的IP。
  - 路由器决定这个数据包是能直接发送给目标主机，还是需要发送给下一个路由器。
  - 依次反复，一直到达目标IP地址。

​    不可能出现路由器查了查然后不知道下一步怎么走，因为这样的路由器是不允许存在的，这个这个路由器是有BUG的（该路由器内算法有问题）。



- **那么如何判定当前这个数据包该发送到哪里呢?**

​	  这个就依靠每个节点内部维护一个路由表。

![img](https://img-blog.csdnimg.cn/1f9148fb326644bfa5f5ff874ca3cb7d.png)





- **路由表查询的具体过程**

每个路由器内部会维护一个路由表，我们可以通过`route`命令查看云服务器上对应的路由表。

![img](https://img-blog.csdnimg.cn/c819de76394c48eaaa5e6952f01e1e7e.png)

- `Destination`代表的是目的网络地址。
- `Gateway`代表的是下一跳地址。
- `Genmask`代表的是子网掩码。
- `Flags`中，U标志表示此条目有效（可以禁用某些条目）G标志表示此条目的下一跳地址是某个路由器的地址，没有G标志的条目表示目的网络地址是与本机接口直接相连的网络，不必经路由器转发。
- `Iface`代表的是发送接口。

- 如果目的IP命中了路由表，就直接转发即可。

- 路由表中的最后一行，主要由下一跳地址和发送接口两部分组成，**当目的地址与路由表中其它行都不匹配时，就按缺省路由条目规定的接口发送到下一跳地址**。

  

   说白了就是，当收到一个报文，（根据从上到下）依次拿该报文和子网掩码按位与，以此得到的报文的目的网络，然后将结果与子网掩码对应的目的网络地址Destination进行比对，如果相等就直接通过Iface代表的发送接口，发送出去（说明该数据包下一跳就应该跳去对应的子网）。eth0就是我们在对应的网络方式中所对应的网路转发接口。

  > ifconfig 是一个用于配置和显示 Linux 网络接口信息的命令。它可以用来查看当前系统中的网络接口信息，包括 IP 地址、MAC 地址、子网掩码、网络状态等。此外，ifconfig 命令也可以用来配置网络接口的参数，如设置 IP 地址、激活或停用网络接口等操作。在最新的 Linux 发行版中，ifconfig 命令被 ip 命令所替代，并且在一些系统中可能需要使用 sudo 权限才能执行。

  ![img](https://img-blog.csdnimg.cn/9ae6f5504c19477e9f844e73d9918a03.png)

   如果将该数据包的目的IP地址与子网掩码进行“按位与”后，没有找到匹配的目的网络地址，此时路由器就会将这个数据包发送到默认路由，也就是路由表中目标网络地址中的default。可以看到默认路由对应的Flags是UG，实际就是将该数据转给了另一台路由器，让该数据在另一台路由器继续进行路由。



**路由器的查找结果可能有以下两种：**

- **路由表查询后（查得到）：**得知该数据下一跳应该跳到哪一个子网。
- **路由表查询后（查不到）：**没有发现匹配的子网，此时路由器会将该数据转发给默认路由。



**假设某主机上的网络接口配置和路由表如下：**

![img](https://img-blog.csdnimg.cn/0845e407216344359c59c5c72d526ce3.png)

**转发过程例1：**如果要发送的数据包的目的地址是192.168.56.3

- 跟第一行的子网掩码做与运算得到192.168.56.0，与第一行的目的网络地址不符。

- 再跟第二行的子网掩码做与运算得到192.168.56.0，正是第二行的目的网络地址，因此从 eth1 接口发送出去。

- 由于192.168.56.0/24正是与 eth1 接口直接相连的网络，因此可以直接发到目的主机，不需要经路由器转发。

  

**转发过程例2：**如果要发送的数据包的目的地址是202.10.1.2

-  依次和路由表前几项进行对比，发现都不匹配。
- 按缺省路由条目，从eth0接口发出去，发往192.168.10.1路由器。
- 由192.168.10.1路由器根据它的路由表决定下一跳地址。



**融汇贯通的理解：**

>  其实网络的拓扑结构可以想象成一个图状的结构。本文为了方便讲述，IP地址是以地区进行的划分，但是实际的情况是更加的复杂的多的多（因为网络不是均分的，而是按照分类的方式进行划分的，所以网路是一个非常复杂的拓扑结构）。



---



### 路由表生成算法

路由可分为静态路由和动态路由：

 

- 静态路由：是指由网络管理员手工配置路由信息。
- 动态路由：是指路由器能够通过算法自动建立自己的路由表，并且能够根据实际情况进行调整。

路由表相关生成算法：距离向量算法、LS算法、Dijkstra算法等。

---



# 总结

 TCP协议：帮我们解决的可靠性问题，但是并不是做实际的数据转发的（明显路由器就没有传输层）。

 IP协议**：**提供一种能力，将数据从A主机送到B主机的能力。

**所以正真的网络环境是：**

![img](https://img-blog.csdnimg.cn/bee6148ca6824c93b3ec560f3c4782fa.png)

  于是TCP/IP协议便可以可靠的将数据从A主机送到B主机。

![img](https://img-blog.csdnimg.cn/5258d583947c4c719ccbe5b0d29746c5.png)



**其在做转发的时候是根据：**

1. 目的IP
2. 子网划分
3. 路由表查找与路由算法

  然后，最终以跨网络的方式将数据从主机B送到主机C。可是想通过以路径选择的方式将数据送到主机C，首先就要解决数据从主机B到路由器F，然后再解决路由器F到路由器G，以此一路到主机C。所以再回头看，**IP协议其实并没有解决设备转发的具体功能实现，IP提供的是转发的策略**。

​    实际上是主机B的数据经过决策发现需要发送到路由器F，所以IP协议的核心工作根本就不是转发，而是做路径选择，实际上IP协议没有能力将报数据包扔出（没有办法将数据直接通过网络层，扔到对方的网络层），而必须将数据交付给下一层。

​    所以更深的解决就是局域网转发的问题，由下层解决。





1. 数据包格式定义：IP协议定义了数据包的格式，包括头部和数据部分的结构，确保数据能够正确被封装和传输。
2. 数据包的路由：IP协议根据目标地址对数据包进行路由，确定数据包在网络中的传输路径，使得数据能够从发送端到达目标设备。
3. 数据包的转发：IP协议使用路由表等信息，将收到的数据包转发到合适的下一跳设备，从而实现数据在网络中的传输。
4. 数据包的寻址：IP协议定义了全球唯一的IP地址，通过这些地址能够准确定位网络中的设备，从而实现数据的传输和通信。
