![img](https://img-blog.csdnimg.cn/3cd1fd2f36b94b76bd6cb3b2bcbf2c27.png)

- **应用层**（http、https）**：** 数据的使用。
- **传输层**（UDP、TCP）**：**网络通讯的细节，将数据可靠的从A主机跨网络送到B主机。

- **网络层**（IP）**：**提供一种能力，将数据从A主机送到B主机的能力。
- **数据链路层：** 用于同一个局域网下的两个设备 （同一种数据链路节点） 之间进行传递。



> - 名称

- **TCP报文：**数据段

- **IP报文：**数据报

- **链路层报文：**数据帧



- IP拥有将数据跨网络从一台主机送到另一台主机的能力，但IP并不能保证每次都能够将数据可靠的送到对端主机，因此IP需要上层TCP为其提供可靠性保证，比如数据丢包后TCP可以让IP重新发送数据，最终在TCP提供的可靠性机制下IP就能够保证将数据可靠的发送到对端主机。
- TCP除了对下层IP提供可靠性机制之外，TCP对上还提供进程到进程的服务，我们在进行socket编程时，本质就是在使用TCP或UDP为我们提供的进程到进程的服务。
- 但数据在网络传输时需要一跳一跳的从一台主机跳到另一台主机，最终才能将数据转发到目标主机，因此要将数据发送到目标主机的前提是，需要先将数据转发给与当前主机直接相连的下一跳主机，而两台主机直接相连也就意味着这两台主机属于同一网段，因此将数据转发到下一跳主机实际是属于局域网通信范畴的，而这实际就是链路层需要解决的问题。
- 也就是说，网络层IP提供的是跨网络发送数据的能力，传输层TCP是为数据发送提供可靠性保证的，而链路层解决的则是两台相连主机之间的通信问题。



---

## **数据链路层**

### **对比理解 "数据链路层" 和 "网络层"**

![img](https://img-blog.csdnimg.cn/16ca94d37e7f4121a68811d085af4808.png)



> - **决定将数据交付给下一跳路由器的时候，下一跳路由器一定和我在同一个局域网。**

所以每一跳之间，本质上的两个节点间的一跳都叫做：局域网转发（子网转发）。所以宏观上，我们的网络的本质就是一个一个子网构成的。只不过子网和子网之间用对应的路由器进行了连接，路由器的工作就是在这么一个个子网当中不断进行转发、进行决策。所以查找的目标主机的时候必须得先找到目标主机所在的子网。

 所以网络的最后一层要解决的就是，如何做到将主机A的数据转发到同一个局域网下的路由器A，如此便可以做到后续在各自局域网中的一跳（都是局域网子网问题）。

---



### **认识以太网**

- **"以太网"** 不是一种具体的网络，而是一种技术标准。既包含了数据链路层的内容，也包含了一些物理层的内容。例如：规定了网络拓扑结构，访问控制方式，传输速率等。
- 例如：以太网中的网线必须使用双绞线（网线），传输速率有10M、100M、1000M等。
- 以太网是当前应用最广泛的局域网技术，和以太网并列的还有令牌环网，无线LAN等。



> - **直接查看链路层数据帧的格式。**

#### **以太网帧格式**

> - **几乎任何协议都要首先解决的两个问题：a、如何分离（封装）？ b、如何交付（分用）？**



![img](https://img-blog.csdnimg.cn/45903af77e1a4d13baf702e556f23854.png)

在局域网当中，想进行转发的时候，首先必须保证每一台主机的唯一性。因为IP地址实际上是[网络层](https://so.csdn.net/so/search?q=网络层&spm=1001.2101.3001.7020)的概念，所以在数据链路层当中无法去标定唯一一台主机，所以对于数据数据链路层，需要一个标识主机的唯一方案：***\*MAC地址\****（物理地址 / 网卡地址）！ 

 MAC地址：是一个48位的整数，是网卡在出厂时就内嵌到网卡中的，是一个固定的序列，用来标识网卡的唯一性，每一台主机只要携带网卡了，都至少必配一个MAC地址。MAC地址在全球也是唯一的，不过其主要的运用场景不是广域网当中，而是局域网当中标定特定一台主机的唯一性，所以只要网卡是唯一的，用网卡的主机就是唯一的。

​    **个人理解：**虽然使用IP也是可以的，毕竟在局域网内，私有IP照样是具有唯一性的，但是此处数据链路层采取的是MAC地址（另一套地址方案）—— 主要是不想让数据链路层，有任何使用IP的方式在里面，以达到在软件上进行一定程度上的解耦。

 

- **目的地址：**需要去哪一台主机的MAC地址。
- **源地址：**是哪一台主机发送的报文的MAC地址。
- **类型：**决定了将有效载荷交付给上层谁的问题。
- **帧协议类型字段有三种：**IP协议、ARP协议、RARP协议。
- **帧末尾：**是CRC校验码。

---



> - **如何分离（封装）？**

​    以太网的帧格式采用的是定长报头，帧末尾CRC校验码同样也是定长。

![img](https://img-blog.csdnimg.cn/fe7d5df25dc841c795a98d3755cdf4c2.png)

 所以，当[数据链路层](https://so.csdn.net/so/search?q=数据链路层&spm=1001.2101.3001.7020)向上层网络层进行交付的时候，只需要将数据帧中的报头和有效载荷进行固定长度的分离就行了（头、尾定长一去就是有效载荷）。解包之后每一个字段该怎么拿，字段的位置与大小也都是固定的，很方便拿。



> - **如何交付（分用）？**

![img](https://img-blog.csdnimg.cn/4b10afcb63c740dea5851875af26f447.png)

​    这两个字段如果填的是0800，代表的就是有效载荷放的是IP报文，进而向上交付给IP层就行了。同样的还有0806、8035，以表明有效载荷不同，从而交付给不同的软件层。

![img](https://img-blog.csdnimg.cn/7d34fa7eebff4a0e848eaff4b6827056.png)

---



> - **重谈局域网通信原理。**

![img](https://img-blog.csdnimg.cn/eb616400343e4299a9c92586a51afaa6.png)

就如同一个班级在进行点名，老师A进行一一的点名，当点同学F的时候，老师A点名的这个行为，学生B、C、D、E是都听到了的（在坐的所有人都是听到的），但是只有学生F答了一声到。而学生F向老师A说的时候，同样的学生B、C、D、E也是都听到了的（在坐的所有人都是听到的）。所以，可以说A和B是在进行众目睽睽之下进行定向的通讯。


​    而之所以学生B、C、D、E，并未做出反应，是因为老师A并未喊道他们，而他们之所以能知道喊的不是他们就是因为他们也听到了的（接收到了的）。



**（主机A向主机B发送报文）**

![img](https://img-blog.csdnimg.cn/ec71a468984d44af9c8b779306bfbece.png)

当在一个局域网中转发报文的时候：

![img](https://img-blog.csdnimg.cn/48aaed7b11aa4bf8b0ee91a1599a2e23.png)

   而收到的每一个主机于是就拿着其中的目的地址进行对比，看是否是自己，不是就直接丢弃，是就保留，做报头和有效载荷的分离，然后将有效载荷向上进行交付。这就是局域网通讯原理：直接把数据仍到局域网当中，其他目标主机自动会去识别该数据，是自己的就留下，不是自己的就丢弃。就相当于喊了一嗓子，通过路由器转发同理，路由器本就是局域网中的主机，其检测到是发送给其的报文就会保留并作后续转发。

---

> - **我们在发数据的时候，别人也想发数据呢？**

 换句话说扔进网路中一个数据帧，也就是扔了一个光电信号。在一个公共的介质当中，你说你的我说我的，彼此信息必定就会发送干扰。也就是说：如果局域网中，同时有多台主机都在发送数据，数据之间就发送了碰撞。



> - **碰撞了发送方主机知道吗？**

 是知道的，就与日常的公共场合说话的一样，是所有人都听的到，包括我们自身。碰撞的时候发送方的主机也是可以知道的（通过CRC校验码 / ……），而一旦碰撞了数据也就无法使用了，所以尽量不能发生碰撞问题，而只有发了才知道会不会碰撞，而如果碰撞了就会激发避免```碰撞算法 ```—— 发送主机会休息随机时间，然后再重新发送。

​    所以数据链路层也需要可靠性。



> - **融汇贯通的理解：**
>
> **结论：**主机A向主机F发送消息，这两台主机是在做进程间通讯。
>
> ​    进程间通讯的本质是，先得让主机A和主机F看见同一份资源，而这的典型的同一份资源就是局域网，所以在读写局域网的时候，因为该局域网被所有主机共享，所以该局域网可以称为**共享资源**。
>
> ​	而我们通过碰撞检测的方式（检测到碰撞，则立马根据相关算法进行重传），一定要保证在己方发数据的时候，没有别人的干扰，这就叫做**对资源进行独占**。
>
> ​	所以，**本质上：局域网资源是一个临界资源**。当我们在进行多个主机通讯的时候，本质上要保证临界资源的数据一致性，就是任何时刻保证一个数据在发。在之前的进程间通讯的学习中是采用的加锁，而在局域网中是先试试，碰撞了就根据一定算法再试试，直到成功即可。



> - **局域网中主机越多越好，还是主机越少越好？**

 主机越少越好， 就和一个公共场合中人多人少导致说话碰撞多的问题，这也就是为什么局域网不能太大，如果局域网太大就会出现一发数据就碰撞一发数据就碰撞的问题，导致数据发送不出去。这也证明了三大运营商的强大，在一个人口巨大的活动下，我们还能正常的进行看视频等网上娱乐，这点也能证明，那个活动场所地区附近的基站的转发能力是十分十分的强大的。



> - **如果非得在局域网中连接很多很多的主机怎么办？**

 所以会存在一种设备：**交换机**。

**交换机特性：**

- 利用交换机将局域网划分成很多很多的子区域，这些子区域依旧属于局域网。

![img](https://img-blog.csdnimg.cn/b72924cca04e45bab39287ad672b5173.png)

 这个时候A与F处于一个局域网，如果A想给F发送报文，可以经过交换机直接将报文给F没有任何问题。但是如果B、D、E也有类似的操作，导致发生碰撞，然后交换机识别到碰撞了，交换机就不会将数据往后转发，此时就减少了碰撞的垃圾数据填充的问题。

- 如果A向B发送消息，交换机就甄别到在其包括的局域网一侧，交换机就不会将数据转发到另一侧了。

 这样大大减小了压力，在另一侧得数据，交换机以同样得方式进行处理。

**总结：**

​	   **交换机的作用：**划分碰撞域。

---



> - **局域网数据帧发送的时候，数据帧越长越好，还是越短越好？**

  越短越好， 越长代表着其要花费更多的时间在局域网中进行传输，更容易发送碰撞。而太短也不好，太短涵盖的有效数据量又太少了。

---



#### **认识MTU**

MTU 相当于发快递时对包裹尺寸的限制， 这个限制是不同的数据链路对应的物理层， 产生的限制。

- 以太网帧中的数据长度规定最小46字节，最大1500字节，ARP数据包的长度不够46字节，要在后面补填充位。

- 最大值1500称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU。
- 如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU了，则需要对数据包进行分片（fragmentation）。
- 不同的数据链路层标准的MTU是不同的。



> - **攻击局域网原理**

我们想让局域网瘫痪，让别人上不了网很简单，只要不断的疯狂的向局域网中发送消息就完了。写一个不断的使用网卡发送请求的程序是很简单的，可是我们也是局域网中的一个主机，一旦碰撞了，我们的主机会自动进行碰撞避免算法，是很难影响的。而网上是有一些工具的，而这些工具是可以绕过数据链路层的，然后不采用数据链路层的碰撞避免算法，然后直接将数据打包给网卡，让网卡直接给发送出去，这个数据无意义。而是绕过碰撞避免算法，所以碰撞就碰撞了，没事继续发，然后导致局域网中其他用户无法上网。

---

> - **汇总到整体的通讯流程中，发现问题 -- 填补问题**

在网络转发的过程中，目的IP是不变的。

----

> - **那MAC帧报头会发生变化吗？**

一定会， 因为每一个主机都有不同的MAC地址，所以当报文跳一个路由器之后，下一跳的MAC源地址与MAC目的地址就变化了

![img](https://img-blog.csdnimg.cn/db23ded8bde4474a84199fe2570dee14.png)

所以有效数据载荷没有变化，但是MAC帧报头是发生变化的。



> - **融汇贯通的理解：**
>
>    每一个路由器，一定会级联多个子网，而每一个子网都有网络号，所以每一个路由器一定有多个条目（一定是一张表，每一个表内部的条目都会涵盖目标网络是谁，子网掩码是什么，是否正常使用），然后当收到一套报文的时候，先拿报文当中的目的IP和路由表的子网掩码按位&，然后再与表中目标网路进行对比，是就扔出，不是就继续查找，这就是路由表。
>

然而，对于上述情况还有一个问题。就是我们上述讲的都是讲报文向上一层局域网进行交付，而IP报文，被千里进行推送，而到达了一个主机的入口路由器，那接下来就是将报文交付给这个目标主机，但是入口路由器封装MAC报头，就必须知道目标主机的MAC地址！所以此时我们就需要有一个如何让一台主机再同一个局域网内知道另一台目标主机的对应的MAC地址。所以便要有新的协议：```ARP协议。```


----

### 小结

#### MAC地址

- MAC地址用来识别数据链路层中相连的节点。
- 长度为48位, 及6个字节，一般用16进制数字加上冒号的形式来表示（例如: 08:00:27:03:fb:19）。
- 在网卡出厂时就确定了, 不能修改。mac地址通常是唯一的（虚拟机中的mac地址不是真实的mac地址，可能会冲突，也有些网卡支持用户配置mac地址）。



**查看Linux的mac地址：**

​    使用***\**\*ifconfig\*\**\***命令。

![img](https://img-blog.csdnimg.cn/eac66f787067416f8a7a7bed3ee12c16.png)

  ether就是以太的意思，后面跟的就是当前主机所对应的MAC地址。如果是虚拟机的话，看见的MAC地址可能有多个，是由虚拟机虚拟出来的，而实际上我这个云服务器的MAC地址也是虚拟出来的，对于云服务器不用管，未来认为其是一台实际的机器就可以了，因为云服务器给我们的不一定是在一台机器上，有可能只是用了一个机器的一部分资源（其是按资源进行划分的）。

----



#### **对比理解MAC地址和IP地址**



- IP地址在整个转发过程中，尤其是目的IP是一直不变的，IP地址的目标一直不变给我们带来的好处就是：IP地址描述的是路途总体的 **起点** 和 **终点**。

- MAC地址描述的是路途上的每一个区间的起点和终点。

> **就如同我们唐僧的取经路：**
>
> - **唐僧的出发地到目的地：**东土大唐 -> 西天。
> - **唐僧的长途跋涉途中：**东土大唐 -> …… -> 车迟国 -> 黑风岭 -> …… ->西天。
> - ![img](https://img-blog.csdnimg.cn/52e7ee55cc7b460e9e28b6875e3dbc6f.png)
> - **源IP -> 目的IP：**是永远都不会改变的。
> - **源MAC -> 目的MAC：**会根据当前所处的位置，不断的进行变化。
> - 目的MAC是受目的IP的影响的，以此到达目地的IP。

---



#### **MTU对IP协议的影响**



> 由于数据链路层MTU的限制，对于较大的IP数据包要进行分包。

-  将较大的IP包分成多个小包，并给每个小包打上标签。
- 每个小包IP协议头的16位标识（id）都是相同的。
- 每个小包的IP协议头的3位标志字段中，第2位置为0，表示允许分片，第3位来表示结束标记（当前是否是最后一个小包，是的话置为1，否则置为0）。
- 到达对端时再将这些小包，会按顺序重组，拼装到一起返回给传输层。
- 一旦这些小包中任意一个小包丢失，接收端的重组就会失败，但是IP层不会负责重新传输数据。

![img](https://img-blog.csdnimg.cn/7e90d72a90f34a73b5a73ca59d2e53b1.png)

![img](https://img-blog.csdnimg.cn/037102bc86034eabb84f4f5595a985ac.png)

---



#### **MTU对UDP协议的影响**

让我们回顾一下 UDP 协议：

- 一旦UDP携带的数据超过1472（1500 - 20(IP首部) - 8(UDP首部)），那么就会在网络层分成多个IP数据报。

- 这多个IP数据报有任意一个丢失，都会引起接收端网络层重组失败。那么这就意味着，如果UDP数据报在网络层被分片，整个数据被丢失的概率就大大增加了。

---



#### **MTU对于TCP协议的影响**

> 让我们再回顾一下 TCP 协议：

  对TCP的影响和UDP是一样的，只不过TCP会重传，但是毕竟也是会消耗资源的，所以尽量还是不要分片。因为MAC帧的规定而导致的网路层发生分片，就会增加丢包概率。而为了减少这样的情况，那么此时就应该让IP报文将自身交付给MAC帧时（充当MAC帧的有效载荷的时候）长度不要超过1500，也就是IP报文整体大小不要超过1500。

 可是之前讲过，IP协议要发多大的数据，是不由IP协议决定，IP协议就是一个跑腿的，真正的决策（一次发送多大的数据、发多少、丢包了怎么办）是由传输层决定的，所以IP协议也没有办法。

所以此时因该能够让TCP单次发送报文的时候，报文的大小不要错过某一个数字： ***\*MSS\******（Maximum segment size，最大段尺寸）**。



MSS和MTU的关系

![img](https://img-blog.csdnimg.cn/9d0c42a99eda4c2483e5490ac9ebe7fe.png)

   所以这也就回答了一个问题，就是TCP发送数据时的滑动窗口，滑动窗口范围之内的数据可以直接发送，而并不用对方立马给与应答。而发送的数据并不是整体一个打包直接发送过去，而是一个一个的数据段，然后再一个一个的附上TCP发送，就是因为下层不允许我们将数据一次发送过去，因为最根上MTU有这样的规定。所以为了保证IP不分片，所以要设置对应的MSS：![img](https://img-blog.csdnimg.cn/df10e4d07b234b8091f6fa8c7ec5e1a4.png)

![img](https://img-blog.csdnimg.cn/67c036a6b7314034960ee1f77d99b863.png)

- TCP的一个数据报也不能无限大，还是受制于MTU。TCP的单个数据报的最大消息长度，称为MSS（Max Segment Size）。
- TCP在建立连接的过程中，通信双方会进行MSS协商。



在最开始的时候，一个数据都没有发，因为这个MTU有可能会变化，其次发送方也想让接收方知道，其单次发送一个报文的大小 - MSS的大小（为了更顺畅的进行通讯）。所以在进行建立链接的时候，双方就会进行MSS的协商，也就是三次握手的时候，除了会协商双方的接收能力，也会进行协商双方单个报文的大小，尽量减少数据发送体积的问题。

- 最理想的情况下，MSS的值正好是在IP不会被分片处理的最大长度（这个长度仍然是受制于数据链路层的MTU）。
- 双方在发送SYN的时候会在TCP头部写入自己能支持的MSS值。
- 然后双方得知对方的MSS值之后，选择较小的作为最终MSS。
- MSS的值就是在TCP首部的40字节变长选项中（ kind = 2 ）。



> **融汇贯通的理解：**
>
>   这也正说明了，分片不是主流，因为当它们在建立握手的过程中的时候，交换了双方的MSS，而做了这个工作，双方在进行后续的通讯的时候，其中的数据报文的大小也就不会再出现分片问题了。

---



## **ARP协议 ** -> 地址解析协议

虽然我们在这里介绍ARP 协议 ， 但是需要强调 ，ARP 不是一个单纯的数据链路层的协议 ，而是一个介于数据链路层和网络层之间的协议。

![img](https://img-blog.csdnimg.cn/92100ea8470b4a11b10be5c1cdaa0b55.png)



对于入口路由器只有F的目标IP地址：IP = 目标网路 + 目标主机 -> 必须知道F的MAC地址 -> 如果没有MAC地址，入口路由器就没有办法在数据连路层封装MAC帧。而如果我们只知道目标主机的IP地址，而不知道对方的MAC地址，也就是说我们需要，在同一个网段中通过目标IP，得知对方的MAC地址： ARP协议 （地址解析协议）。 而因为其是在同一个网段中，所以其是一个局域网协议。



> - **能不能根据路由器 + 该报文的目标IP，确认清楚这个报文一定在它的子网当中的？**

   100%能做到，因为当一个报文送来的时候，它的目的IP是知道的，然后可以根据查路由表获取到目标网络，然后再和当前网络所对应的路由表目的网络做比较，来确定报文是否已经到达目标网络。

  最终确定到达目标网络，再根据整体的IP地址，再根据***\*ARP协议\****获取目标主机F所对应的MAC地址（因为前面已经确定该目标IP一定属于当前网段中），获取到之后再封装MAC帧，于是便可以将数据转给主机F了。



> - **以太网协议（MAC帧）与ARP协议之间有什么关系？**

​    二者是属于在同一个大层，但是在同一个大层里面是分为了不同的层次：

- **最底层：**以太网协议，（最典型）MAC帧。

- **上层：**属于局域网协议，ARP协议。

  

  ARP、RARP和MAC帧协议虽然都属于数据链路层的协议，但ARP协议和RARP协议属于MAC帧的上层协议

   

  ![img](https://img-blog.csdnimg.cn/a43fa77dd53a4758a9ebe280ee4771e1.png)



- 也就是说，MAC帧的上层协议不一定就直接是网络层的协议，MAC帧的上层协议有可能也属于数据链路层的协议，但就是位于MAC帧的上层。
- 与之类似的，网络层当中的ICMP协议和IGMP协议，这两个协议虽然与IP协议都属于网络层，但这两个协议属于IP的上层协议。



   ARP协议和MAC帧同属于数据链路层，只不过二者又是上下层的关系，这就是为什么以太网帧当中有一个帧类型，它用来表述的要么是ARP、要么是网络层中的协议。

![img](https://img-blog.csdnimg.cn/7d34fa7eebff4a0e848eaff4b6827056.png)

---



### **ARP数据报的格式**



> - **ARP的工作过程**

其就像高中新来的一位老师，对于他班里的学生的姓名是一个也不知道，但是他有一张记有每一个人的学号，但是没有名字，于是老师需要念学号的方式认识同学，而老师在念学号且让其告诉姓名的操作，无疑是一次班内的广播，于是每一个同学都会收到这么一个报文，并且最终在局域网中广播的时候一定采用的还是MAC帧。

 于是大家都听见了，然后大家都需要从这个报文中提取学号的信息，也就是IP地址，对比是不是自身。于是，是的留下，不是的丢弃。于是这个是的同学就会发送：我是学号：……，我的名字是：XXX，然后封装位MAC帧，然后将这个消息定向的发送（因为它可以知道是谁问的），本质上还是广播，并且其他同学进行丢弃。


此时老师就知道这个学号的真实姓名，于是这就完成了一次简单的过程，这就叫做***\*ARP\****。

---

> - **小结：**

1. 先广播。
2. 再一对一进行发送。

所有逻辑都属于封装成MAC帧，在局域网当中完成。



> - **ARP协议的细节** 

![img](https://img-blog.csdnimg.cn/7b31f29e08b04c368f639f9b178ce87c.png)



> - **真正的ARP协议：** 

![img](https://img-blog.csdnimg.cn/70d4ed1554014faaa4af385a4846aef3.png)

- **硬件类型：**这次要进行ARP时，对应的局域网的网络种类 / 网络的标准 / 网络的类型，一般固定**1**：为以太网。
- **协议类型：**我们想要转换什么样的地址类型，如：想将IP转换为MAC地址 / ……，一般固定**0x0800**：为IP地址（未来想将IP转换为MAC地址）。
- **硬件地址长度：**通常代表就是，如果是硬件地址长度是MAC地址（以太网地址）固定为6字节。
- **协议地址长度：**通常代表就是，我们是MAC地址表征硬件，IP地址表征软件。一硬一软，对应的就是协议地址对应的就是软件长度，IP地址为固定为4。



前四个为固定写法，就可以不看了，重点是后面的字段。

- **op字段：**为1表示ARP请求，op字段为2表示ARP应答。
- **发送端以太网地址：**发送主机的MAC地址。
- **发送端IP地址：**发送主机的IP地址。
- **目的以太网地址：**ARP请求时：因为目的就是获得目的以太网地址，所以不知道为全F（二进制全1）FFFF。ARP应答时：

- **目的IP地址：**目标主机的IP地址。

---

#### **op字段**

如果一台主机能向另一台主机发起ARP请求，那么在未来除了主机掉线情况，这台主机一定会收到对应的ARP应答。一但一台主机可能向多台都可能未来要发送消息，所以这台主机可能向多台主机都曾经发送过ARP请求，就决定了这台主机他未来一定会收到大量的应答。所以对于一台主机来讲，其在正常工作的时候即可能对外发送ARP，也可能收到ARP。


> **小结**

1. 任何一个主机可能之前向目标主机发送过ARP请求，也就注定了未来会收到对应的ARP应答。
2. 任何一台主机，也可能被别人发起ARP请求。



**局域网中：**任何一台主机收到ARP的时候，可能是一个**应答**，也可能是一个**请求**。所以一个主机收到的ARP就既有可能是应答也有可能是请求，所以需要op进行区分。即：为1表示ARP请求，op字段为2表示ARP应答。



---



### **模拟一次ARP** 

### ![image-20240327182534744](C:\Users\。\AppData\Roaming\Typora\typora-user-images\image-20240327182534744.png)



> - **对于这个报文，除了主机D外，主机B与主机C需不需要进行处理（向上交付）？**

   需要处理！因为如当前主机B收到当前数据帧时，发现目的地址是全F，所以主机B认为是广播，于是每一台主机都认为是广播，所以每一台主机都需要对该数据帧做处理。每一台主机都要做一件事情，将对应的报头和有效载荷进行分离，然后根据它的帧类型来决定将有效载荷交给各自的哪一层，所以这个数据帧任何一个主机都需要向上交付给ARP。

   所以其实每一台主机都会在自己的ARP层当中拿到ARP请求，然后当每一台主机都拿到ARP请求的时候，先看OP类型，因为任何一台主机收到ARP的时候，可能是一个应答，也可能是一个请求，所以需要先区分是请求还是应答。在发现是一个请求之后，再看目的IP地址，然后发现与自生不一样的直接抛弃，与自身一样的才保留。至此整个请求成功的让目标主机成功的收到了，并且目标主机可以根据发送端IP地址与发送端MAC地址知道是谁发送的请求。



> - **再一对一进行发送**

![img](https://img-blog.csdnimg.cn/c021ad904aa7422c90eee39e7e3c52cd.png)

我们发现在ARP中就有一个MAC_A而在MAC帧的报头中，又有一个MAC_A，冲突吗？两个并不冲突，而且二者不但不冲突还处于不同的工作层次的，前面的是给MAC层看的，中间的是给ARP看的。所以这个冗余也是合理的，是通过数据冗余来实现两层协议的解耦合。



> - **对于这个报文，除了主机A外，主机B与主机C需不需要进行处理（向上交付）？**

 **不需要处理！**因为如当前主机B收到当前数据帧时，发现目的地址是MAC_A，就不向上交付了，直接丢弃（之前因为是广播地址，所以不得不向上交付）。

   于是其他主机不处理的直接丢弃，就相当于主机D直接给A发消息（一对一）。

---



#### **小结**

​    在我们刚刚的讲解过程中，发生了两次丢弃，但是两次丢弃的场景是不一样的。

1. **ARP申请时：**ARP层丢弃。
2. **ARP应答时：**MAC层丢弃。

  **ARP前提是我需要知道对方的目的IP，然后根据目的IP来得到所对应的目标主机的MAC地址。**



> - **ARP看起来至少进行一个请求和一个应答，是不是每一次发送数据都要这么干？**

​    并不需要，因为一般ARP请求成功之后，请求方会暂时将IP和MAC的映射关系暂时保存下来，往后请求时会直接使用缓存当中的IP和MAC的映射关系，拿着MAC地址封装MAC帧，然后进行转发。

  其中这个保存是有时间的，比如说：15分钟。如果超时了，操作系统内核自动将该缓存对应的条目去掉。设置时间原因是当前的目标主机，可能会重启 / 关机，然后又来一台主机，导致局域网分配的时候重新分配IP地址，如果此时的MAC地址不更新的话，就无法发送数据，所以是会暂时保存下来。

---



> - **是不是只是会在目标主机最终的子网中进行ARP，其他地方会不会也发生ARP呢？**

   会，ARP的过程会在网络中可能随时在路径中发生，一个子网中发送主机的缓存中就有可能没有目标主机的MAC地址，这个时候需要使用ARP是再正常不过的，不过正是有缓存的存在，ARP在使用中并不是大量的。

其实不光是ARP在路径当中会随时的可能发生，而IP分片也是随时的可能在路上发生，因为我们的数据包在进行路由的时候，整个一条的链路上，每一台主机规定的MTU有可能并不是一样大的，所以发送主机发送的数据大小假设是1500，而路径上的路由器，有可能对应的MTU比较的小，所以最终也可能在路上进行分片（一般特别少），因为一般中间路由器都是运营商设置的，所以他们的设置也是精良减少分片，但是并不能说是被彻底的排除了的。



> MAC帧的报头当中已经涵盖了源和目的MAC地址，为什么ARP的报头当中还要有这两个字段？

- 需要注意的是，MAC帧和ARP虽然都在数据链路层，但毕竟是上下层的关系，因此它们不会互相关心彼此报头当中的数据。
- 此外，如果底层网络采用的不是以太网，而是其他类型的网络，此时ARP层的MAC地址就是必要的了。 



> **在进行局域网通信时，为什么不直接以广播的方式发送数据？**

在进行局域网通信时，就算只知道对方的IP地址，而不知道对方的MAC地址，也可以以广播的方式将数据发送到局域网当中，此时局域网当中的主机也能够在IP层比对目的IP地址与自己是否相符，来判断收到的这个数据是否是发送给自己的。

理论上确实可以这样，但这种方式是不妥的。

- 对于局域网当中的大多数主机来说，收到的这个报文其实早就应该被丢弃，而现在这个报文却交付到了IP层，我们都知道IP层是属于操作系统管控的，因此这对网络资源和系统资源来说都是一种浪费。

- 因此在底层MAC帧层就应该判定这个报文是不是发送给当前主机的，而不是当数据向上交付到了IP层再来判断。

  此外，如果无脑使用广播的方式来进行数据的发送，会使得广播和单播的概念变得模糊不清，你明明是想发送数据给局域网当中的一台主机，但你却采用了广播的方式，这显然是不合理的。



> - **如何查看自己的Linux机器的ARP缓存？**

![img](https://img-blog.csdnimg.cn/1b3c3762bbe444ae8c1479ae5245cb0e.png)



> - **融会贯通的理解：**
>
>     如果想获取一下主机所处的局域网中所有主机的MAC和IP地址。
>
>   **1.** 先使用**ifconfid**使用子网掩码通过IP地址拿到网络号：
>
>   ![img](https://img-blog.csdnimg.cn/823a678763c74980b1dd98359fcf81b3.png)
>
>   2. ```number=1; while [ $number -le 254 ]; do ping "192.168.0.$number"; let number++; done ```
>
>       所以在局域网当中，只要想办法去ping一下局域网中所有的IP地址。ping的过程其实就是向其发包的过程，而向其发包的前提就是需要知道MAC地址，然后底层就会自动触发ARP。于是便会将对应的局域网中的所有主机的IP和MAC的映射关系全部缓存起来。



> - **ARP伪装 / ARP攻击，使用ARP让自己成为中间人。**

   因为ARP的缓存是取新而不取旧，是只要有新的ARP应答，主机就会对ARP缓存表进行更新。

![img](https://img-blog.csdnimg.cn/b88c2fb0d08542edab0e4c601f7346bc.png)



所以外部来到路由器A的报文，其会将报文转给主机B，但是由于主机C不断的ARP应答，导致MAC被更改，而将报文转给主机C，然后主机C就会将数据获取后再转发给主机B。所以这样主机C就在路由器A和主机B不知情的情况下，成为了A和B的中间人。就是因为ARP可以疯狂的伪造ARP应答，并且只需要将ARP应答内的MAC更改成自己的就可以了 - ARP欺骗。

 但是所有的数据都是由HTTPS加密的所以拿到了是没有任何用的 - 但是这样是可以定向的搞掉一台机器，就是让其上不了网。采用这种思路，让主机C向主机B推送ARP应答，填写一个路由器的IP但是是主机C的MAC地址MAC_B / 错误的MAC地址，这样主机B发送的所有的数据路由器A都拿不到。

 话句话说，想定向的让一个主机断网，我们只需要给其发送一定量的ARP，给其ARP缓存表填写一个错误的MAC。
