## 1. **http协议**



在http协议的学习中，让我们知道：

- http携带数据的时候，是明文的，所以一定程度上来说，是一个不够安全的协议。万一有不法分子，通过一定的手段，抓到了http对应的一些请求，那么这样带来的直接后果就是：该数据直接泄漏。

- 所以现在，主流的用户协议是https。



- **那么http协议的不安全因数，其存在还具有什么意义？**

> 因为在非用户场景下，比如：公司内部，http协议的不安全一定意味着，其不用做数据保护，也就是相对于[https协议](https://so.csdn.net/so/search?q=https协议&spm=1001.2101.3001.7020)，http协议做更少的事情。在确保公司内网安全的情况下，相对于效率更好的http协议，当然是更受欢迎的。



---

## 2. **https协议**

在http协议的学习中，让我们知道：



-  https协议，也是⼀个应用层协议.，是在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输保护数据传输安全的协议。 

- 而在之前的 **GET** 和 **POST** 方法，无论是哪一个：都是不够安全的，最多可以说POST方法是够私密的，因为其以 http 请求正文的形式进行参数传递，GET是通过 url 传递。



### ***安全***

 那么需要对于一个数据保证其的安全性，那么就一定需要进行加密，加密也就会有解密。



- **如何正确的理解安全？**

>  **安全 == 网络安全**，没有100%的真正安全，只有实际理论上的安全：破解的成本远远大于破解的收益。

> **网络五层模型：**
>
> ![img](https://img-blog.csdnimg.cn/a35fa2066d814223ab93082bb3beda20.png)
>
>  就是因为 http 协议属于应用层，所以我们才能够用套接字接口来自己简单的封装出一个 http 。然后让浏览器做一定的解释，使得我们可以看到通过我们的网络请求，以此能够将相关数据，显示到浏览器上。



  而为了安全起见，实际上还可以在应用层再添加一个模块：**TLS / SSL（Secure Socket Layer）** 

![img](https://img-blog.csdnimg.cn/ee6d7718edeb4eb4b6cdb931375b22a9.png)

  而：**http协议 + TLS / SSL == https协议** 

  于是通过在通讯双方主机上的应用层中添加 TLS / SSL ，使得数据在网路中一定是经过加密的，以此达到对数据的保护。

---



## 3. **概念**



### 3.1 **什么是"加密"？**

- **加密：**就是把 **明文** (要传输的信息)进行一系列变换, 生成 ***\*密文\**** 。

- **解密：**就是把 **密文**再进行⼀系列变换, 还原成 **明文** 。



 在这个加密和解密的过程中，往往需要⼀个或者多个中间的数据，辅助进行这个过程，这样的数据称为密钥。加密解密到如今已经发展成⼀个独立的学科：密码学。而密码学的奠基人，也正是计算机科学的祖师爷之⼀：艾伦·⻨席森·图灵。

![img](https://img-blog.csdnimg.cn/c422739fd58746e880afe41ef2a25019.png)



### 3.2 **为什么要加密？**



> **臭名昭著的 "运营商劫持"**
>
> - 比如在以前，下载⼀个天天动听：
>
>   - **未被劫持的效果：**点击下载按钮，就会弹出天天动听的下载链接，并且正确的下载天天动听app。
>
>   ![img](https://img-blog.csdnimg.cn/16a363c324684babb04e1bd1720b244d.png)
>
>   - **已被劫持的效果：**点击下载按钮，就会弹出 QQ 浏览器的下载链接，下载的不是天天动听app。
>
>     ![img](https://img-blog.csdnimg.cn/86169865ca114162add14e1b1ebfaf29.png)
>
>      
>
>     由于，我们通过网络传输的任何的数据包都会经过运营商的网络设备（路由器，交换机等），那么运营商的网络设备就可以解析出我们传输的数据内容，并进行篡改。即，点击 "下载按钮"，其实就是在给服务器发送了⼀个 HTTP 请求，获取到的 HTTP 响应其实就包含了该 APP 的下载链接。那么运营商劫持之后，就发现这个请求是要下载天天动听，于是就自动的把交给用户的响应给篡改成 "QQ浏览器" 的下载地址了。
>
>     所以：因为http的内容是明文传输的，明文数据会经过路由器、wifi热点、通信服务运营商、代理服务器等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是 **中间人攻击** ，所以我们才需要对信息进行加密。



- **关于信息泄漏的攻击方式：99%中间人攻击。**

>    不止运营商可以劫持，其他的黑客也可以用类似的手段进行劫持，来窃取用户隐私信息，或者篡改内容。 （试想⼀下, 如果黑客在用户登陆⽀付宝的时候获取到用户账户余额，甚至获取到用户的⽀付密码.....）
>         所以，在互联网上, 明文传输是比较危险的事情！https 就是在 http 的基础上进行了加密，进⼀步的来保证用户的信息安全。



- **"中间人"：**

> - 我们的手机开热点给他人使用：
>
>   >  其实连接热点的人的数据报文，就必须经过我们的手机***\*（我们的手机 ≈ 路由器）\****，然后其所有的消息都会推到我们的手机，然后让我们的手机帮（代为）其推送。如果其使用的是http协议，这个时候如果我们装有一定的抓包数据的软件等，我们就可以将其信息进行获取。
>
> - 路上免费的WIFI等……。



---

### 3.3 **常见的加密方式**



#### 3.3.1 **对称加密**

- 采用单钥密码系统的加密方法，同⼀个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密，**特征：加密和解密所用的密钥是相同的。**
- 常见对称加密算法(了解)：DES、3DES、AES、TDEA、Blowfish、RC2等。

- 特点：算法公开、计算量小、加密速度快、加密效率高等。



对称加密其实就是通过同⼀个 "密钥" ，把明文加密成密文，并且也能把密文解密成明⽂.

> ⼀个简单的对称加密，按位异或：
>                 假设：明文 a = 1234, 密钥 key = 8888
>                 则加密 a ^ key 得到的密文 b 为 9834
>                 然后针对密文 9834 再次进行运算 b ^ key，得到的就是原来的明文 1234
> 				(对于字符串的对称加密也是同理，每⼀个字符都可以表示成⼀个数字)
>
>    当然，按位异或只是最简单的对称加密，https 中并不是使用按位异或

---



#### 3.3.2 **非对称加密**

- 需要两个密钥来进行加密和解密，这两个密钥是公开密钥（public key，简称公钥）和私有密钥 （private key，简称私钥）。

- 常见非对称加密算法(了解)：RSA，DSA，ECDSA

- 特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。



> 非对称加密要用到两个密钥，⼀个叫做 "公钥"，⼀个叫做 "私钥"。
>
> 公钥和私钥是配对的，最大的缺点就是**运算速度非常慢**，比对称加密要慢很多。

- 通过公钥对明文加密：变成密文。
- 通过私钥对密文解密：变成明文。

也可以反着用

- 通过私钥对明文加密：变成密文。
- 通过公钥对密文解密：变成明文。



>  非对称加密的数学原理比较复杂，涉及到⼀些数论相关的知识，这里举⼀个简单的生活上的例子：
>
> A 要给 B ⼀些重要的文件，但是 B 可能不在。于是 A 和 B 提前做出约定：
>                 B 说：我桌子上有个盒子，然后我给你⼀把锁，你把文件放盒子里用锁锁上，然后我回头拿着钥匙来开锁取文件。
>                 在这个场景中，这把锁就相当于公钥，钥匙就是私钥。公钥给谁都行（不怕泄露），但是私钥只有 B 自己持有，持有私钥的人才能解密。



***\*实际举例：\**** 网上托管代码厂库gitee就有：采用代码提交方式中的 **SSH**。

> ![img](https://img-blog.csdnimg.cn/d756635e9125471c9858280bd9677e40.png)
>
>  这个时候就需要在我们对应的账户下，设置对应的公钥：
>
> ![img](https://img-blog.csdnimg.cn/2e07161977ce4daf91887f0477ef3c0b.png)
>
>    公钥：本地通过一定的对应的工具形成，形成之后我们将对应的私钥保留，然后将对应的公钥放在这上面。



### 3.4 **数据摘要 && 数据指纹**



- 数字指纹（数据摘要），其基本原理是利用单向散列函数（Hash函数）对信息进行运算，生成⼀串固定长度的数字摘要，数字指纹并不是⼀种加密机制，但可以用来判断数据有没有被窜改。

![img](https://img-blog.csdnimg.cn/f19d74735d14490bac7e941b0c7c33c5.png)



- 摘要常见算法：有MD5、SHA1、SHA256、SHA512等，算法把无限的映射成有限，因此可能会有碰撞（两个不同的信息，算出的摘要相同，但是概率非常低）。

- 摘要特征：和加密算法的区别是，摘要严格意义不是加密，因为没有解密，只不过从摘要很难反推原信息，通常用来进行数据对比。



***场景：***

 对于公司数据库中的私密信息也是保密的（就算的程序员打开数据库也看不懂）。

![img](https://img-blog.csdnimg.cn/6394ebd5741f45cbbd831aae7d26341f.png)



#### 3.4.1 **数字签名**

- 摘要经过加密，就得到数字签名（后面细说）。

> **可以说：**数据摘要不是加密，毕竟是加密就一定要有对应的解密。

---



## 4. **HTTPS 的工作过程探究**

 既然要保证数据安全，就需要进行"加密"。网络传输中不再直接传输明文了, 而是加密之后的 "密文"，加密的方式有很多，但是整体可以分成两大类： ***\*对称加密\**** 和  ***\*非对称加密\**** 。



### 4.1 **方案一：只使用对称加密**

 如果通信双方都各自持有同⼀个密钥X，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。

![img](https://img-blog.csdnimg.cn/0ffcb0977a4a49b7b31d6cb25bb1764c.png)

这个过程就相当于：客户端与服务器之间使用密钥进行通讯。而这个时候，在网络的中间环节，黑客即便是入侵了路由器并截获了请求，但是因为其没有密钥，所以其根本无法进行解密。于是这种方案就是一种安全的方案。



- **但是这个方法的问题还是有很多！**

  > 引入对称加密之后，即使数据被截获，由于黑客不知道密钥是啥，因此就无法进行解密，也就不知道请求的真实内容是啥了。 
  >
  > - **但事情没这么简单：**
  >
  > - 怎么保证客户端与服务器具有同样的一个密钥？
  > - 客户端有一个密钥怎么样服务器知道？传递？不就也泄漏了吗？
  >
  > ![img](https://img-blog.csdnimg.cn/4cfb2da691334a359535499d0d9aa62c.png)
  >
  >  所以客户端如何让服务器知道密钥，是并不容易的。所以：**这个方案也就不可取了！**



- 采取设备出厂就内置密钥呢？

1. 黑客也有可以买设备，也可以知道密钥（如果是相同那密钥就太容易扩散了，黑客就也能拿到了）。
2. 服务器同⼀时刻其实是给很多客户端提供服务的，这么多客户端，每个人用的秘钥都必须是不同的。因此服务器就需要维护每个客户端和每个密钥之间的关联关系，这也是个很麻烦的事情！

![img](https://img-blog.csdnimg.cn/059fc53be448498d996093d8724a6a44.png)

 所以：**这个方案也就不可取了！**

> **通过总结：*****因此密钥的传输也必须加密传输！***
>
> ​    但是要想对密钥进行对称加密，就仍然需要先协商确定⼀个 "密钥的密钥"。这就成了 "先有鸡还是先有蛋" 的问题了。此时密钥的传输再⽤对称加密就行不通了。

---



### 4.2 方案二：只使用非对称加密



鉴于非对称加密的机制，如果服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，从客户端到服务器信道似乎是安全的，因为只有服务器有相应的私钥能解开公钥加密的数据。



- **但是：** **服务器到浏览器的这条路怎么保障安全？**

>  如果服务器用它的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是⼀开始通过明文传输给浏览器的，若这个公钥被中间人劫持到了，那他也能用该公钥解密服务器传来的信息了。

- **通过上面的特点，我们是不是使用各自相对方提供公钥即可？**



---

### 4.3 方案三：双方都使用非对称加密



1. 服务端拥有 **公钥S** 与对应的 **私钥S'** ，客⼾端拥有 **公钥C** 与对应的 **私钥C'** 。
2. 客户和服务端交换公钥。
3. 客户端给服务端发信息：先用 **S** 对数据加密，再发送，只能由服务器解密，因为只有服务器有 **私钥** **S'** 。
4. 服务端给客⼾端发信息：先用 **C** 对数据加密，在发送，只能由客户端解密，因为只有客户端有 **私钥** **C'** 。



**这样貌似也行，但是：**

- 效率太低：非对称加密，本身就非常的慢，而在上述中，双方都采用非对称加密。
- 依旧有安全问题：与下一个方案相同，见下一个方案。

---



### 4.4 **方案四：非对称加密 + 对称加密**



- **先解决效率问题**

1. 服务端具有非对称 **公钥S** 和 **私钥S'** 。
2. 客户端发起 https请求，获取服务端 **公钥S** 。
3. 客户端在本地生成对称 **密钥C** , 通过 **公钥S** 加密, 发送给服务器。
4. 由于中间的网络设备没有私钥，即使截获了数据，也无法还原出内部的原文，也就无法获取到对称密钥（真的吗?）
5. 服务器通过 **私钥S'** 解密，还原出客户端发送的对称 **密钥C** ，并且使用这个对称密钥加密给客户端返回的响应数据。后续客户端和服务器的通信都只用对称加密即可，由于该密钥只有客户端和服务器两个主机知道，其他主机 / 设备不知道密钥即使截获数据也没有意义。

![img](https://img-blog.csdnimg.cn/4b0198ce44a74e59b2bfd777b650a484.png)



- **于是：****便可以双方进行对称的密钥X进行加密通讯** 

>  由于对称加密的效率比非对称加密高很多，因此只是在开始阶段协商密钥的时候使用非对称加密，后续的传输仍然使用对称加密。



- **但是：** **虽然上面已经比较接近答案了，依旧有安全问题**

> **方案 2，方案 3，方案4，都存在一个问题，如果最开始，中间人就已经开始攻击了呢？**



### 4.5 **中间人攻击 - 针对上面的场景**



- Man-in-the-MiddleAttack，简称： ***\*“MITM攻击”\**** 

 确实，在方案2、3、4中，客户端获取到 **公钥S** 之后，对客户端形成的对称 **密钥X** 用服务端给客户端的 **公钥S** 进行加密，中间人即使窃取到了数据，此时中间人确实无法解出客户端形成的 **密钥X** ，因为只有服务器有 **私钥S'** 

 但是中间人的攻击，如果在最开始握手协商的时候就进行了，那就不⼀定了，假设 hacker 已经成功成为中间人：

1. 服务器具有非对称加密算法的 ***\*公钥S\**** ， ***\*私钥S'\**** 。
2. 中间人具有非对称加密算法的 ***\*公钥M\**** ， ***\*私钥M'\**** 。
3. 客户端向服务器发起请求，服务器明文传送 ***\*公钥S\**** 给客户端。
4. 中间人劫持数据报文，提取 ***\*公钥S\**** 并保存好，然后将被劫持报文中的 ***\*公钥S\**** 替换成为自己的 ***\*公钥M\**** ，并将伪造报文发给客户端。
5. 客户端收到报文，提取 ***\*公钥M\**** （自己当然不知道公钥被更换过了)，自己形成对称 ***\*秘钥X\**** ，用 ***\*公钥M\**** 加密 ***\*X\**** ，形成报文发送给服务器。
6. 中间人劫持后，直接用自己的 ***\*私钥M'\**** 进行解密，得到通信 ***\*秘钥X\**** ，再用曾经保存的服务端 ***\*公钥S\**** 加密后，将报文推送给服务器。
7. 服务器拿到报文，用自己的 ***\*私钥S'\**** 解密，得到通信 ***\*秘钥X\**** 。
8. 双方开始采用 ***\*X\**** 进行对称加密，进行通信。但是⼀切都在中间人的掌握中，劫持数据，进行窃听甚⾄修改，都是可以的。

![img](https://img-blog.csdnimg.cn/48b4bd63e3a84d95bb5213aa1310621a.png)

-  上面的攻击方案，同样适用于方案2，方案3。



- **问题本质出在哪里了呢？**

>  客户端无法确定收到的含有公钥的数据报文，就是目标服务器发送过来的！



> 核心： 只要已经交换了秘钥了，中间人来就晚了，中间人在最开始的时候，就可以进行篡改替换。
> 本质： 是中间人能够对数据做篡改 && Client无法验证接收到的公钥是合法（是目标服务器的公钥）的。



### 4.6 **引入证书**

- 为了解决上诉的问题，于是便有了：**引入证书**。为了解决上面的问题，Client就需要对服务器的合法性进行认证。



#### 4.6.1 **CA认证**

 服务端在使用 HTTPS 前，需要向CA机构申领⼀份数字证书，数字证书里含有证书申请者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了， **证书就如身份证，证明服务端公钥的权威性** （因为政府是可信的，所以其给予的身份证也是可信的） 。



- **权威机构 -- CA机构**
- **颁发证书 -- CA证书**

![img](https://img-blog.csdnimg.cn/7c6e7bebbadd436fb370b90d4d9d5620.png)



基本说明： [CA认证_百度百科 (baidu.com)](https://baike.baidu.com/item/CA认证/6471579?fr=aladdin)

这个 ***\*证书\**** 可以理解成是⼀个结构化的字符串，里面包含了以下信息：

> - 证书发布机构
> - 证书有效期
> - 公钥
> - 证书所有者
> - 签名

 需要注意的是：申请证书的时候，需要在特定平台生成查，会同时生成⼀对密钥对，即公钥和私钥。这对密钥对就是用来在网络通信中进行明文加密以及数字签名的。

 其中公钥会随着CSR文件，⼀起发给CA进行权威认证，私钥服务端自己保留，用来后续进行通信 （其实主要就是用来交换对称秘钥）

![img](https://img-blog.csdnimg.cn/9b57e02fd0294427865848b10885f435.png)

![img](https://img-blog.csdnimg.cn/4028e19441ef4c73bda66a0eb19428bc.png)



可以使用在线生成CSR和私钥： [CSR在线生成工具 (myssl.com)](https://myssl.com/csr_create.html)

形成CSR之后，后续就是向CA进行申请认证，不过⼀般认证过程很繁琐，网络各种提供证书申请的服务商，⼀般真的需要，直接找平台解决就行。

---

#### 4.6.2 **理解数据签名**

 签名的形成是基于非对称加密算法的。

>  **目前暂时和https没有关系，不要和https中的公钥、私钥搞混了。**

  前面提到过：***\*摘要经过加密，就得到数字签名\****

![img](https://img-blog.csdnimg.cn/9a4d0b751a1c4a80a5153ca0a8efc141.png)

当服务端申请CA证书的时候，CA机构会对该服务端进行审核，并专门为该网站形成数字签名，过程如下：

1. CA机构拥有非对称加密的 ***\*私钥A\**** 和 ***\*公钥A'\**** 
2. CA机构对**服务端申请的证书明文数据**进行hash，形成数据摘要
3. 然后对数据摘要用 CA私钥A' 加密，得到 数字签名S

 服务端申请的证书明文和数字签名S共同组成了数字证书，这样⼀份数字证书就可以颁发给服务端了。

> **核心：**
>     由于明文数据进行hash，形成数据摘要，而只要明文改动一点，都会照成hash算法形成的数据摘要出现大变动。而原本的数据摘要加密是通过是只有服务器端才有私钥。
>
> ​    所以，没有办法将一个新的数据摘要进行私钥的修饰，变为数字签名，然后让公钥打开，而公钥又只能打开私钥加密的数据（**主要原因：**就是因为这组非对称密钥，是CA机构提供的。并且，CA私钥不公开，CA公钥公开）。



- **CA是如何签发证书的？**

>   CA机构，也有自己的非对称秘钥： ***\*公钥A\**** 、 ***\*私钥A'\**** 。
>
> ![img](https://img-blog.csdnimg.cn/7d9336f480b74dddb2ed6bea10a61104.png)



### 4.7 方案五：非对称加密 + 对称加密 + 证书认证



  在客户端和服务器刚⼀建立连接的时候，服务器给客户端返回⼀个证书，证书包含了之前服务端的公钥，也包含了网站的⾝份信息。

![img](https://img-blog.csdnimg.cn/bb1fe0155cad49b498471ba22d23c44e.png)

> ***\*Note：\****
>
> **解决上述方案四中问题关键：**
>
> 1. **中间人能够对数据做篡改。**
> 2. **Client无法验证接收到的公钥是合法（是目标服务器的公钥）的。**



- ***\*中间人能够对数据做篡改。\****

![img](https://img-blog.csdnimg.cn/4c4d0d3541014a7eb913c1e5a2e9ad35.png)

如果中间人对证书的客户端公钥进行篡改为自己的公钥，但是对于CA私钥不公开，于是就无法形成一个，CA公钥打开的数据。**（主要：CA私钥不公开，CA公钥公开）**一般CA公钥是内置的。

- 中间人篡改了证书的明文。
- 由于他没有CA机构的私钥，所以⽆法hash之后用私钥加密形成签名，那么也就没法办法对篡改后的证书形成匹配的签名。
- 如果强行篡改，客户端收到该证书后会发现明文和签名解密后的值不⼀致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。



> **融汇贯通的理解：**
>
> ​    一般客户端，在认证证书的时候，其只认其内部的公钥信息，这个公钥信息是一些CA / CA的子机构给我们的浏览器内，内置的公钥信息。
>
> ![img](https://img-blog.csdnimg.cn/1919f0f3a5d5432f88edc47b1e315a22.png)
>
> ![img](https://img-blog.csdnimg.cn/6398c50a18b940d29fbc335d06dfb850.png)
>
> ![img](https://img-blog.csdnimg.cn/56912861fb334dd287baaa0df735ee9c.png)



- **中间人整个掉包证书？**

- 因为中间人没有CA私钥，所以无法制作假的证书！
- 所以中间人只能向CA申请真证书，然后用自己申请的证书进行掉包。（真证书是由域名的，地址都不同！相当于一个人拿了另一个人的身份证，这看不出来？）
- 这个确实能做到证书的整体掉包，但是别忘记，证书明文中包含了域名等服务端认证信息，如果整体掉包，客⼾端依旧能够识别出来。



> **永远记住：中间人没有CA私钥，所以对任何证书都无法进行合法修改，包括自己的。**



#### 4.7.1 如何解决的？

> **确保信息未被修改：**`摘要算法 + 数字签名`- 每一步交换数据都需要使用

> 对原始文本进行**`摘要算法`**提取得到**摘要**，**摘要**经过加密，就得到**`数字签名`**。其会和原始文本一起发送到对端。对端通过同样的对原始文本进行**`摘要算法`**提取得到**摘要**，再将**`数字签名`**进行解密得到摘要，二者进行对比。

> **确保信息加密：**`数字证书 + 非对称加密 + 对称加密` - 最初HTTPS握手执行一次
>
> **数据传输加密核心：**利用传输双方仅有的**`对称密钥`**进行加密。
>
> 保证**`对称密钥`**仅双方具有：利用**`非对称密钥`**进行客户端**`对称密钥`**交换，但是需要保证明文公钥是由目标服务器发出，所以需要**`数字证书`**认证。
>
> **`数字证书`**由CA机构形成，利用CA**`非对称加密`** + **`数字签名`** 确保就是目标服务器的公钥。因为：**`数字签名`**的加密密钥都是独有的 - CA私钥（中间人无法进行加密）。

---



## 5. 常见问题



 **为什么摘要内容在网络传输的时候一定要加密形成签名?**

> 常见的摘要算法有: MD5 和 SHA 系列，以 MD5 为例：我们不需要研究具体的计算签名的过程，只需要了解 MD5 的特点：

- **定长：**无论多长的字符串，计算出来的 MD5 值都是固定长度（16字节版本或者32字节版本）。
- **分散：**源字符串只要改变⼀点点，最终得到的 MD5 值都会差别很大。
- **不可逆：**通过源字符串生成 MD5 很容易，但是通过 MD5 还原成原串理论上是不可能的。



**比如：**

  	  假设我们的证书只是⼀个简单的字符串 hello，对这个字符串计算hash值（比如md5），结果为：BC4B2A76B9719D91。
        如果 hello 中有任意的字符被篡改了，比如变成了 hella，那么计算的 md5 值就会变化很大：BDBD6F9CF51F2FD8。
        然后我们可以把这个字符串 hello 和 哈希值 BC4B2A76B9719D91 从服务器返回给客户端，此时客户端如何验证 hello 是否是被篡改过?

   那么就只要计算 hello 的哈希值，看看是不是 BC4B2A76B9719D91 即可！

![img](https://img-blog.csdnimg.cn/b649a66f13594dc59748bf417a06a69c.png)



- **为什么签名不直接加密，而是要先hash形成摘要？**

缩小签名密文的长度，加快数字签名的验证签名的运算速度。



---



- 如何成为中间人 - 了解

- **ARP欺骗：**在局域网中，hacker 经过收到ARP Request广播包，能够偷听到其它节点的 (IP、 MAC) 地址。例：黑客收到两个主机A、B的地址，告诉B (受害者) ，自己是A，使得 B 在发送给 A 的数据包都被黑客截取。
- **CMP攻击：**由于ICMP协议中有重定向的报文类型，那么我们就可以伪造一个ICMP信息然后发送给局域网中的客户端，并伪装自己是一个更好的路由通路。从而导致目标所有的上网流量都会发送到我们指定的接口上，达到和ARP欺骗同样的效果。
- **假wifi** && ***\*假网站\**\**（镜像网站）\****等。



## 6. 完整流程



- 左侧都是客户端做的事情，右侧都是服务器做的事情。

![img](https://img-blog.csdnimg.cn/6b5be04f83ce44cc8bfd4c8bc093c3a5.png)





## 7. **总结**

 **HTTPS 工作过程中涉及到的密钥有三组：**

-   第一组（非对称加密）：用于校验证书是否被篡改。服务器持有私钥（私钥在形成CSR文件与申请证书时获得），客户端持有公钥（操作系统包含了可信任的 CA 认证机构有哪些，同时持有对应的公钥）。服务器在客户端请求是，返回携带签名的证书。客户端通过这个公钥进行证书验证，保证证书的合法性，进⼀步保证证书中携带的服务端公钥权威性。
-  **第二组（非对称加密）：**用于协商生成对称加密的密钥。客户端用收到的CA证书中的公钥（是可被信任的）给随机生成的对称加密的密钥加密，传输给服务器，服务器通过私钥解密获取到对称加密密钥。

-  **第三组（对称加密）：**客户端和服务器后续传输的数据都通过这个对称密钥加密解密。其实⼀切的关键都是围绕这个对称加密的密钥，其他的机制都是辅助这个密钥工作的。

  

  第二组非对称加密的密钥是为了让客户端把这个对称密钥传给服务器。

  第一组非对称加密的密钥是为了让客户端拿到第二组非对称加密的公钥。