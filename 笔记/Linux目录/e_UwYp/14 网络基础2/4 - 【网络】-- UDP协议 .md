## 1. **传输层**



在学习HTTP等[应用层协议](https://so.csdn.net/so/search?q=应用层协议&spm=1001.2101.3001.7020)时，为了便于理解，可以简单的认为HTTP协议是将请求和响应直接发送到了网络当中。但实际应用层需要先将数据交给传输层，由传输层对数据做进一步处理后再将数据继续向下进行交付，该过程贯穿整个网络协议栈，最终才能将数据发送到网络当中。

- 传输层- > 负责数据能够从发送端传输接收端。



## 2. **再谈端口号**

- 端口号（Port） 标识了一个主机上进行通信的不同的应用程序.

  当主机从网络中获取到数据后，需要自底向上进行数据的交付，而这个数据最终应该交给上层的哪个应用处理程序，就是由该数据当中的目的端口号来决定的。

  

  ![img](https://img-blog.csdnimg.cn/cfd4c794a7a5480998f20696c47004cd.png)



- 说白了就是进行通讯的不同的进程。所以当底层收到数据时，其如果只知道目标地址，其根据IP地址就能找到对应的主机。但是接下来需要知道的就是，这个数据报应该向上递交给哪一个进程，即根据对应的Port端口号。



- 五元组标识一个通信

>  在 **TCP/IP协议** 中，用 **"源IP"**，**"源端口号"**，**"目的IP"**，**"目的端口号"**，**"协议号"** 这样一个五元组来标识一个通信 （可以通过 netstat -n查看） 。

> 比如有多台客户端主机同时访问服务器，这些客户端主机上可能有一个客户端进程，也可能有多个客户端进程，它们都在访问同一台服务器。

![img](https://img-blog.csdnimg.cn/580ef51a21ce4735af6f11145525ea49.png)



- 而这台服务器就是通过“源IP地址”，“源端口号”，“目的IP地址”，“目的端口号”，“协议号”来识别一个通信的。

> - 先提取出数据当中的目的IP地址和目的端口号，确定该数据是发送给当前服务进程的。
> - 然后提取出数据当中的协议号，为该数据提供对应类型的服务。
> - 最后提取出数据当中的源IP地址和源端口号，将其作为响应数据的目的IP地址和目的端口号，将响应结果发送给对应的客户端进程。

![img](https://img-blog.csdnimg.cn/5a9200ae26bc4811bc7180bf6e4dbfcd.png)



通过`netstat`命令可以查看到这样的五元组信息。

![img](https://img-blog.csdnimg.cn/0db8f633ecee422e908f0b092e8e738d.png)

> 其中的Local Address表示的就是源IP地址和源端口号，Foreign Address表示的就是目的IP地址和目的端口号，而Proto表示的就是协议类型。



- 协议号 VS 端口号

> - 协议号是存在于IP报头当中的，其长度是8位。协议号指明了数据报所携带的数据是使用的何种协议，以便让目的主机的IP层知道应该将该数据交付给传输层的哪个协议进行处理。

> - 端口号是存在于UDP和TCP报头当中的，其长度是16位。端口号的作用是唯一标识一台主机上的某个进程。

> - 协议号是作用于传输层和网络层之间的，而端口号是作用于应用层于传输层之间的。

---



## 3. **端口号范围划分**

- 端口号的长度是16位，因此端口号的范围是0 ~ 65535：

- 0 ~ 1023：知名端口号。比如HTTP，FTP，SSH等这些广为使用的应用层协议，它们的端口号都是固定的。
- 1024 ~ 65535：操作系统动态分配的端口号。客户端程序的端口号就是由操作系统从这个范围分配的。



### 3.1 **认识知名端口号（Well-Know Port Number）**



- 常见的知名端口号

> 有些服务器是非常常用的，这些服务器的端口号一般都是固定的：

- ssh服务器，使用22端口。
- ftp服务器，使用21端口。
- telnet服务器，使用23端口。
- http服务器，使用80端口。
- https服务器，使用443端口。



- 查看知名端口号

> 可以查看`/etc/services`文件，该文件是记录网络服务名和它们对应使用的端口号及协议。

![img](https://img-blog.csdnimg.cn/992a900f51dd49bb85f5af171a1c45c2.png)

**说明一下：** 文件中的每一行对应一种服务，它由4个字段组成，每个字段之间用TAB或空格分隔，分别表示“服务名称”、“使用端口”、“协议名称”以及“别名”。





- **Note：** 我们自己写一个程序使用端口号时，要避开这些知名端口号。

远程利用windows使用Xshell软件，连接远在外省的机器，因为我们使用的Xshell时客户端，而远端的服务器周而复始的，以启动一个绑定端口是22号的服务：

![img](https://img-blog.csdnimg.cn/bafbf153f6224cfaa9be6c59dee56dad.png)

 进一步查看该服务：

![img](https://img-blog.csdnimg.cn/bc500633f8e54f5dbac41f03bdb17ad3.png)

这个服务以d结尾，表示是守护进程（一般都是，不是强制规定），也可以看见其的SID与PID是相等的。



- > **守护进程：**这个进程不退出，一直在后端提供服务。



> 所以，当我们用Xshell连接之后，我们就能直接登上了，当我们启动的时候，一登陆成功，这个sshd就会在终端当中，为我们形成加载bash进程，然后给我们打出命令符。让我们进行输指令。

> 然后将我们的指令字符串不断以网络发送的形式发送给服务器，然后让服务端执行，然后执行完再将结果给我们。

---

## 4. **两个问题**



- 一个端口号是否可以被多个进程绑定？

> 一个端口号绝对不能被多个进程绑定，因为端口号的作用就是唯一标识一个进程，如果绑定一个已经被绑定的端口号，就会出现绑定失败的问题。

> - **融汇贯通的理解：**
>
> 一个端口号被建立好并和进程绑定，而当有一个报文到了的时候，其是如何将对应的数据交给对应的进程的？
>
> ---
>
> - **常识：**一个进程在进行服务的时候，除了listen套接字之外，每一次获取新连接（都会得到一个新的sockfd），对应的sockfd就是一个文件描述符。
>
> - 换句话说：其实在我们看来一个连接可以说就是一个文件，所以所谓的收到数据的本质就是：将数据放到对应的文件的接收缓冲区里，然后当前进程通过文件描述符进行文件的读取（因为进程与文件是通过文件描述表建立的关系）。无论未来进程想读取数据还是从底层网络里将数据拿上来，我们只要找到了进程，我们就能找到给进程所相关的文件缓冲区。
> - **所以：**对于如何将底层TCP、UDP收到的数据交给特定的网络连接，其实就是转换成了：如何通过底层收到的端口号（携带端口号的相关报文），交付给特定进程。
> -    其做法：在内核当中其是采取哈希映射的关系，可以理解为key值为端口号，value值为进程的PCB的地址，所以当底层一旦收到数据时，系统当中直接查哈希表，直接找到对应的进程，然后就可以通过我们（我们在网络操作中，调用系统调用读数据的时候传的就是文件描述符）文件描述符，直接放在特定的文件当中，然后进程在上层用户调用read的时候就可以读取到了。



- **一个进程是否可以bind多个端口号?**

> 一个进程是可以绑定多个端口号的，这与“端口号必须唯一标识一个进程”是不冲突的，只不过现在这多个端口唯一标识的是同一个进程罢了。
>
> 我们限制的是从端口号到进程的唯一性，而没有要求从进程到端口号也必须满足唯一性，因此一个进程是可以绑定多个端口号的。

---



## 5. 网络指令

### 5.1 **netstat**

`netstat`是一个用来查看网络状态的重要工具。

**语法**：netstat [选项]

**功能**：查看网络状态



其常见的选项如下：

- n：拒绝显示别名，能显示数字的全部转换成数字。
- l：仅列出处于LISTEN（监听）状态的服务。
- p：显示建立相关链接的程序名。
- t(tcp)：仅显示tcp相关的选项。
- u(udp)：仅显示udp相关的选项。
- a(all)：显示所有的选项，默认不显示LISTEN相关。



查看TCP相关的网络信息时，一般选择使用`nltp`组合选项。

![img](https://img-blog.csdnimg.cn/73c98d5ce9bc4b98b40e178729320015.png)

而查看UDP相关的网络信息时，一般选择使用`nlup`组合选项。

![img](https://img-blog.csdnimg.cn/5c7f02d9f4704566b1c9bf55a83e151c.png)

如果想查看LISTEN状态以外的连接信息，可以去掉`l`选项，此时就会将处于其他状态的连接信息显示出来。

![img](https://img-blog.csdnimg.cn/7bd9709e0f5f46b48734165ba92d32d7.png)



### 5.2 **iostat**

`iostat`主要用于输出磁盘IO和CPU的统计信息。

其常见的选项如下：

- c：显示CPU的使用情况。
- d：显示磁盘的使用情况。
- N：显示磁盘列阵（LVM）信息。
- n：显示NFS使用情况。
- k：以KB为单位显示。
- m：以M为单位显示。
- t：报告每秒向终端读取和写入的字符数和CPU的信息。
- V：显示版本信息。
- x：显示详细信息。
- p：显示磁盘分区的情况。

比如我们要查看磁盘IO和CPU的详细信息。

![img](https://img-blog.csdnimg.cn/686cbaf81ab2442a97f7ee611e01247a.png)

CPU属性值说明：

-  %user：CPU处在用户模式下的时间百分比。
- %nice：CPU处在带NICE值的用户模式下的时间百分比。
- %system：CPU处在系统模式下的时间百分比。
- %iowait：CPU等待输入输出完成时间的百分比。
- %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。
- %idle：CPU空闲时间百分比。
  

---

### 5.3 pidof

在查看服务器的进程 id 时非常方便 .

**语法** ： pidof [ 进程名 ]

**功能** ：通过进程名 , 查看进程 id

例如，我们用`pidof`命令查看我们自己编写的一个死循环进程。

![img](https://img-blog.csdnimg.cn/28a4e70e27cd44cbb005d28417010b2e.png)

`pidof`命令可以配合`kill`命令快速杀死一个进程。

![img](https://img-blog.csdnimg.cn/079987c77b8c48518df0c03bfc3360b7.png)

---



## 6. **UDP协议**

UDP就属于传输层，并且端口号也是在传输层起作用。 

![img](https://img-blog.csdnimg.cn/3cd1fd2f36b94b76bd6cb3b2bcbf2c27.png)





- 几乎任何协议都要首先解决的两个问题：a、如何分离（封装）？ b、如何交付？

![img](https://img-blog.csdnimg.cn/897bbf0d986440c6a7e76d65feef04d6.png)

1. 16位源端口号：表示数据从哪里来。
2. 16位目的端口号：表示数据要到哪里去。
3. 16位UDP长度：表示整个数据报（UDP首部+UDP数据）的长度。
4. 16位UDP检验和：如果UDP报文的检验和出错，就会直接将报文丢弃。



- **a、如何分离（封装）？**

>  采用固定报头长度的策略（8个字节）。因为udp是不可靠协议，只要能够保证把数据能够交到对方主机（当然不保证也可以，反正只要发出去）就可以了，所以是固定长度。
>
>    可以保证：将报头和有效载荷的分离。



- **b、如何交付？** 

![img](https://img-blog.csdnimg.cn/1d4b0741a31341e2ab76b3cd6a24e301.png)

根据报头中的16位端口号，进行向上交付。因为进程bind了端口号！之所以可以，就是因为这是一个约定，是一个客户端与服务端都知道，并且必须遵守的约定，这就叫做 **"协议"** 。



**总结：**

- 所以对于应用层的代码编写的时候，都是用uint16_t类型来接收端口号。
- udp通过固定长度的报头中提取到16位的UDP长度，以此知道如何正确的提取整个完整的报文数据。

即：根据上述可知，UDP是具有将报文一个一个正确接收的能力的！则，UDP是面向数据报的。



- **如何理解udp报文的本身？**

 底层中，这里所谓的报头实际上叫做：***\*struct udp_hdr\****。传说中的udp报头，以及未来的所有报头，其实就是一个结构体类型（位断）。

```c++
struct udp_hdr
{
    uint32_t src_port:16;
    uint32_t dst_port:16;
    uint32_t udp_len:16;
    uint32_t udp_check:16;
}
```

---

### 6.1 **UDP**的特点

UDP传输的过程类似于寄信。

- **无连接：**知道对端的IP和端口号就直接进行传输，不需要建立连接。
- **不可靠：**没有确认机制，没有重传机制。如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。

> 不可靠：
>
>     指的是中性的特点，没有贬义的意思。在长距离传输的时候，如果要保证可靠性，一定意味着要做更多的工作，就意味着匹配的协议在实践上更复杂，其由于更加的复杂度，所以，其在使用成本以及维护成本上都是更高的。
>     
>     所以不可靠并不是十分的不好，一定原则上来说，反而更简单。



- **面向数据报:** 不能够灵活的控制读写数据的次数和数量。

> **面向数据报：**
>
>   应用层交给UDP多长的报文，UDP原样发送，既**不会拆分**，也**不会合并**。
>
> 用UDP传输100个字节的数据：
>
> - 如果发送端调用一次sendto，发送100个字节，那么接收端也必须调用对应的一次recvfrom，接收100个字节。
> - 而不能循环调用10次recvfrom，每次接收10个字节。
>
>    怎么发就必须怎么收，发的报文必须是一个完整的报文。





- 重新理解**sendto / recvfrom / write / read / recv / send ……io类接口？**

  **在以往看来：**这些函数是在网络中进行数据的收发（根本不是！）

 这些函数，其实本质是：**拷贝函数！**

![img](https://img-blog.csdnimg.cn/f8173b425913439eaa5279d0b89be8be.png)

应用层用的都是系统调用接口，而目前我们所用的所有协议（通讯原则），全部用的是UDP / TCP提供的接口，所以内核层中的缓冲区一般用的都是传输层协议提供的。

 也就是说：对应传输层 -> 传输，即：**缓冲区**数据什么时候发，发多少，出错了怎么办，由其关心并处理。所以我们在应用层所写的代码，本质上：还是系统编程。我们将数据交给了参数层的**缓冲区，**并没有发送出去。

---

### 6.2 **UDP的缓冲区**

- UDP没有真正意义上的**发送缓冲区。**因为调用sendto会直接交给内核，由内核将数据传给网络层协议进行后续的传输动作。所以其对于发送缓冲区并没有特别强的需求，反正有数据就往下交。

- UDP具有接收缓冲区。但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致；如果缓冲区满了，再到达的UDP数据就会被丢弃。

- UDP的socket既能读，也能写，因此UDP是全双工的。
- 

- 全双工 VS 半双工：

> 全双工 ：一个文件描述符，如果既能读，同时又能写（可以理解为两个线程，同时一个线程读，一个线程写）。保证：只要接收缓冲区和发送缓冲区不冲突即可，不要用同一个缓冲区。

> 半双工：一个文件描述符，再任意时刻，要么只能读，要么只能写，不能二者同时并行（可以理解为两个人正常聊天，只能其中一个人在说话）。



- 为什么UDP要有接收缓冲区？

如果UDP没有接收缓冲区，那么就要求上层及时将UDP获取到的报文读取上去，如果一个报文在UDP没有被读取，那么此时UDP从底层获取上来的报文数据就会被迫丢弃。

一个报文从一台主机传输到另一台主机，在传输过程中会消耗主机资源和网络资源。如果UDP收到一个报文后仅仅因为上次收到的报文没有被上层读取，而被迫丢弃一个可能并没有错误的报文，这就是在浪费主机资源和网络资源。

因此UDP本身是会维护一个接收缓冲区的，当有新的UDP报文到来时就会把这个报文放到接收缓冲区当中，此时上层在读数据的时就直接从这个接收缓冲区当中进行读取就行了，而如果UDP接收缓冲区当中没有数据那上层在读取时就会被阻塞。因此UDP的接收缓冲区的作用就是，将接收到的报文暂时的保存起来，供上层读取。




---



### 6.3 **UDP使用注意事项**

我们注意到，UDP协议首部中有一个16位的最大长度，也就是说一个UDP能传输的数据最大长度是64K（包含UDP首部）。

 然而64K在当今的互联网环境下，是一个非常小的数字。如果我们需要传输的数据超过64K，就需要在应用层手动的分包，多次发送，并在接收端手动拼装。

---

### 6.4 **基于UDP的应用层协议** 

- NFS：网络文件系统。
- TFTP：简单文件传输协议。
- DHCP：动态主机配置协议（比如：笔记本连接网络前，上不了网，本质：没有IP地址。当连上网后，笔记本会自动获取一个IP地址，是路由器给的IP地址，就是路由器中部署了一种服务：DHCP）。
- BOOTP：启动协议（用于无盘设备启动）。
- DNS：域名解析协议。
  